/*
* JBoss, Home of Professional Open Source.
* See the COPYRIGHT.txt file distributed with this work for information
* regarding copyright ownership. Some portions may be licensed
* to Red Hat, Inc. under one or more contributor license agreements.
*
* This library is free software; you can redistribute it and/or
* modify it under the terms of the GNU Lesser General Public
* License as published by the Free Software Foundation; either
* version 2.1 of the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public
* License along with this library; if not, write to the Free Software
* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
* 02110-1301 USA.
*/

options {
    STATIC = false;
    ERROR_REPORTING = true;
    JAVA_UNICODE_ESCAPE = true;
    UNICODE_INPUT = false;
    IGNORE_CASE = true;
    MULTI = true;
    BUILD_NODE_FILES = false;
    NODE_PREFIX = "";
    NODE_SCOPE_HOOK = false;
    NODE_USES_PARSER = true;
    NODE_PACKAGE = "org.teiid.query.sql.lang";
    VISITOR = false;
    VISITOR_RETURN_TYPE = "void";
    GRAMMAR_ENCODING="UTF-8";
    KEEP_LINE_COLUMN = true;
    NODE_FACTORY = "TeiidNodeFactory";
}

PARSER_BEGIN(Teiid7ClientParser)

/*
* JBoss, Home of Professional Open Source.
* See the COPYRIGHT.txt file distributed with this work for information
* regarding copyright ownership. Some portions may be licensed
* to Red Hat, Inc. under one or more contributor license agreements.
*
* This library is free software; you can redistribute it and/or
* modify it under the terms of the GNU Lesser General Public
* License as published by the Free Software Foundation; either
* version 2.1 of the License, or (at your option) any later version.
*
* This library is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* Lesser General Public License for more details.
*
* You should have received a copy of the GNU Lesser General Public
* License along with this library; if not, write to the Free Software
* Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
* 02110-1301 USA.
*/
package org.teiid.query.parser.v7;

import java.math.BigInteger;
import java.util.*;
import java.util.regex.Matcher;
import org.komodo.spi.runtime.version.TeiidVersion;
import org.komodo.spi.runtime.version.DefaultTeiidVersion;
import org.komodo.spi.query.sql.lang.MatchCriteria.MatchMode;
import org.komodo.spi.query.JoinTypeTypes;
import org.teiid.runtime.client.Messages;
import org.teiid.language.SortSpecification.NullOrdering;
import org.teiid.metadata.Column;
import org.teiid.metadata.BaseColumn.NullType;
import org.teiid.metadata.Table;
import org.teiid.query.parser.AbstractTeiidClientParser;
import org.teiid.query.parser.ParsedDataType;
import org.teiid.query.parser.ParseInfo;
import org.teiid.query.parser.TeiidNodeFactory;
import org.teiid.query.parser.TeiidNodeFactory.ASTNodes;
import org.teiid.query.sql.lang.*;
import org.teiid.query.sql.lang.CriteriaOperator.Operator;
import org.teiid.query.sql.lang.SubqueryCompareCriteriaImpl.PredicateQuantifier;
import org.teiid.query.sql.proc.*;
import org.teiid.query.sql.symbol.*;
import org.teiid.core.types.DefaultDataTypeManager;
import org.teiid.core.util.StringUtil;

/** 
 * <p>The SQLParser is a JavaCC-generated parser that reads a SQL string and produces a 
 * Query object.  The SQLParser.java file is generated by JavaCC from the SQLParser.jj
 * file.  <B>WARNING:</B> DO NOT MODIFY the SQLParser.java file as it will be 
 * regenerated from the .jj file and your changes will be lost!</p>
 */
@SuppressWarnings({"nls", "unused", "javadoc"})
public class Teiid7ClientParser extends AbstractTeiidClientParser {

    private String getComment(Token t) {
        Token optToken = t.specialToken;
        if (optToken == null) { 
            return ""; //$NON-NLS-1$
        }

        //handle nested comments
        String image = optToken.image;
        while (optToken.specialToken != null) {
            optToken = optToken.specialToken;
            image = optToken.image + image;
        }

        String hint = image.substring(2, image.length() - 2);
        if (hint.startsWith("+")) { //$NON-NLS-1$
            hint = hint.substring(1);
        }

        return hint;
    }

    private boolean isNonStrictHint(Token t) {
        String[] parts = getComment(t).split("\\s"); //$NON-NLS-1$
        for (int i = 0; i < parts.length; i++) {
            if (parts[i].equalsIgnoreCase(LimitImpl.NON_STRICT)) {
                return true;
            }
        }
        return false;
    }

    private SourceHintImpl getSourceHint(Token t) {
        String comment = getComment(t);
        Matcher matcher = SOURCE_HINT.matcher(comment);
        if (!matcher.find()) {
            return null;
        }
        SourceHintImpl sourceHint = new SourceHintImpl();
        String generalHint = matcher.group(1);
        if (generalHint != null) {
            sourceHint.setGeneralHint(normalizeStringLiteral(generalHint));
        }
        int end = matcher.end();
        matcher = SOURCE_HINT_ARG.matcher(comment);
        while (matcher.find(end)) {
            end = matcher.end();
            sourceHint.setSourceHint(matcher.group(1), normalizeStringLiteral(matcher.group(2)), false);
        }
        return sourceHint;
    }

    private SubqueryHint getSubqueryHint(Token t) {
        SubqueryHint hint = new SubqueryHint();
        String[] parts = getComment(t).split("\\s"); //$NON-NLS-1$
        for (int i = 0; i < parts.length; i++) {
            if (parts[i].equalsIgnoreCase(SubqueryHint.MJ)) {
                hint.setMergeJoin(true);
            } else if (parts[i].equalsIgnoreCase(SubqueryHint.NOUNNEST)) {
                hint.setNoUnnest(true);
            } else if (parts[i].equalsIgnoreCase(SubqueryHint.DJ)) {
                hint.setDepJoin();
            }
        }
        return hint;
    }

    private void setFromClauseOptions(Token groupID, FromClauseImpl fromClause){
        String[] parts = getComment(groupID).split("\\s"); //$NON-NLS-1$

        for (int i = 0; i < parts.length; i++) {
            if (parts[i].equalsIgnoreCase(OptionImpl.OPTIONAL)) {
                fromClause.setOptional(true);
            } else if (parts[i].equalsIgnoreCase(OptionImpl.MAKEDEP)) {
                fromClause.setMakeDep(true);
            } else if (parts[i].equalsIgnoreCase(OptionImpl.MAKENOTDEP)) {
                fromClause.setMakeNotDep(true);
            } else if (parts[i].equalsIgnoreCase(FromClauseImpl.MAKEIND)) {
                fromClause.setMakeInd(true);
            } else if (parts[i].equalsIgnoreCase(SubqueryHint.NOUNNEST)) {
                fromClause.setNoUnnest(true);
            }
        }
    }

    /**
     * Generate an expression name based on the function type and previous names.
     * @param info Parse info, including counts for each function type
     * @param functionType Null for expression, the function name for aggregates
     * @return New unique function name
     */
    private String generateFunctionName(ParseInfo info, String functionType) {
        if (functionType == null) {
            functionType = "expr"; //$NON-NLS-1$
        } else {
            functionType = functionType.toLowerCase();
        }
        if (info.nameCounts == null) {
            info.nameCounts = new HashMap<String, Integer>();
        }
        Integer num = info.nameCounts.get(functionType);
        if (num == null) {
            num = 0;
        }
        info.nameCounts.put(functionType, num + 1);
        return functionType + (num == 0 ? "" : ""+num); //$NON-NLS-1$   //$NON-NLS-2$  
    }

    @Override
    public TeiidVersion getVersion() {
        if (version == null)            version = new DefaultTeiidVersion("7.7.x");

        return version;
    }

} // end class

PARSER_END(Teiid7ClientParser)

TOKEN_MGR_DECLS : 
{
    int commentNestingDepth; 
} 

SKIP :
{
	" " | "\t" | "\n" | "\r"
}

MORE :
{
  "/*" { commentNestingDepth = 1 ; } : IN_MULTI_LINE_COMMENT
}

<IN_MULTI_LINE_COMMENT>
MORE : 
{  
  "/*" { commentNestingDepth += 1 ; } 
} 

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN : 
{  
  "*/" { 
    commentNestingDepth -= 1;
    SwitchTo( commentNestingDepth==0 ? DEFAULT : IN_MULTI_LINE_COMMENT ) ; 
  }
} 

<IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

TOKEN: /* Data types */
{
	<STRING: "string">
|   <VARCHAR: "varchar">
|	<BOOLEAN: "boolean">
|	<BYTE: "byte">
|   <TINYINT: "tinyint">
|	<SHORT: "short">
|   <SMALLINT: "smallint">
|	<CHAR: "char">
|	<INTEGER: "integer">
|	<LONG: "long">
|   <BIGINT: "bigint">
|	<BIGINTEGER: "biginteger">
|	<FLOAT: "float">
|   <REAL: "real"> 
|	<DOUBLE: "double">
|	<BIGDECIMAL: "bigdecimal">
|   <DECIMAL: "decimal">
|	<DATE: "date">
|	<TIME: "time">
|	<TIMESTAMP: "timestamp">
|	<OBJECT: "object">
|	<BLOB: "blob">
|	<CLOB: "clob">
|	<XML: "xml">
}


TOKEN: /* Functions with special syntax */
{
	<CAST: "cast">
|	<CONVERT: "convert">
}

TOKEN : /* Reserved words */
{
    <ADD: "add">
|   <ALL: "all">
|   <ALTER: "alter">
|   <AND: "and">
|   <ANY: "any">
|   <ARRAY: "array">
|   <ARRAY_AGG: "array_agg">
|   <AS: "as">
|   <ASC: "asc">
|   <ATOMIC: "atomic">
|   <AUTORIZATION: "authorization">
|   <BEGIN: "begin">
|   <BETWEEN: "between">
|   <BINARY: "binary">
|   <BOTH: "both">
|   <BREAK: "break">
|   <BY: "by">
|   <CALL: "call">
|   <CALLED: "called">
|   <CASCADED: "cascaded">
|   <CASE: "case">
|   <CHARACTER: "character">
|   <CHECK: "check">
|   <CLOSE: "close">
|   <COLLATE: "collate">
|   <COLUMN: "column">
|   <COMMIT: "commit">
|   <CONNECT: "connect">
|   <CONSTRAINT: "constraint">
|   <CONTINUE: "continue">
|   <CORRESPONDING: "corresponding">
|   <CURRENT_DATE: "current_date">
|   <CURRENT_TIME: "current_time">
|   <CURRENT_TIMESTAMP: "current_timestamp">
|   <CURRENT_USER: "current_user">
|   <CREATE: "create">
|   <CRITERIA: "criteria">
|   <CROSS: "cross">
|   <CURSOR: "cursor">
|   <DAY: "day">
|   <DEALLOCATE: "deallocate">
|   <DEFAULT_KEYWORD: "default">
|   <DECLARE: "declare">
|   <DELETE: "delete">
|   <DESC: "desc">
|   <DESCRIBE: "describe">
|   <DETERMINISTIC: "deterministic">
|   <DISCONNECT: "disconnect">
|   <DISTINCT: "distinct">
|   <DROP: "drop">
|	<EACH: "each">
|   <ELSE: "else">
|   <END: "end">
|   <ERROR: "error">
|   <ESCAPE: "escape">
|   <EXCEPT: "except">
|   <EXEC: "exec">
|   <EXECUTE: "execute">
|   <EXTERNAL: "external">
|   <EXISTS: "exists">
|   <FALSE: "false">
|   <FETCH: "fetch">
|   <FILTER: "filter">
|   <FOR: "for">
|   <FORIEGN: "foriegn">
|   <FROM: "from">
|   <FULL: "full">
|   <FUNCTION: "function">
|   <GET: "get">
|   <GLOBAL: "global">
|   <GRANT: "grant">
|   <GROUP: "group">
|   <HAS: "has">
|   <HAVING: "having">
|   <HOLD: "hold">
|   <HOUR: "hour">
|   <IF: "if">
|   <IDENTITY: "identity">
|   <IMMEDIATE: "immediate">
|   <IN: "in">
|   <INDICATOR: "indicator">
|   <INNER: "inner">
|   <INPUT: "input">
|   <INOUT: "inout">
|   <INSENSITIVE: "insensitive">
|   <INSERT: "insert">
|   <INTERSECT: "intersect">
|   <INTERVAL: "interval">
|   <INTO: "into">
|   <IS: "is">
|   <ISOLATION: "isolation">
|   <JOIN: "join">
|   <LEFT: "left">
|   <LANGUAGE: "language">
|   <LARGE: "large">
|   <LEADING: "leading">
|   <LEAVE: "leave">
|   <LIKE: "like">
|   <LIKE_REGEX: "like_regex">
|   <LIMIT: "limit">
|   <LOCAL: "local">
|   <LOOP: "loop">
|   <MAKEDEP: "makedep">
|   <MAKENOTDEP: "makenotdep">
|   <MATCH: "match">
|   <MERGE: "merge">
|   <METHOD: "method">
|   <MINUTE: "minute">
|   <MODIFIES: "modifies">
|   <MODULE: "module">
|   <MONTH: "month">
|   <NATURAL: "natural">
|   <NEW: "new">
|	<NOCACHE: "nocache">
|   <NO: "no">
|   <NONE: "none">
|   <NOT: "not">
|   <NULL: "null">
|   <OF: "of">
|   <OFFSET: "offset">
|   <OLD: "old">
|   <ON: "on">
|   <ONLY: "only">
|   <OPEN: "open">
|   <OPTION: "option">
|   <OR: "or">
|   <ORDER: "order">
|   <OUTER: "outer">
|   <OUTPUT: "output">
|   <OVER: "over">
|   <OVERLAPS: "OVERLAPS">
|   <PARAMETER: "parameter">
|   <PARTITION: "partition">
|   <PRECISION: "precision">
|   <PREPARE: "prepare">
|   <PRIMARY: "primary">
|   <PROCEDURE: "procedure">
|   <RANGE: "range">
|   <READS: "reads">
|   <RECURSIVE: "recursive">
|   <REFERENCES: "REFERENCES">
|   <REFERENCING: "REFERENCING">
|   <RETURN: "return">
|   <RETURNS: "returns">
|   <REVOKE: "REVOKE">
|   <RIGHT: "right">
|   <ROLLBACK: "ROLLBACK">
|   <ROLLUP: "ROLLUP">
|   <ROW: "row">
|   <ROWS: "rows">
|   <SAVEPOINT: "savepoint">
|   <SCROLL: "scroll">
|   <SEARCH: "search">
|   <SECOND: "second">
|   <SELECT: "select">
|   <SENSITIVE: "sensitive">
|   <SESSION_USER: "session_user">
|   <SET: "set">
|   <SIMILAR: "similar">
|   <SPECIFIC: "specific">
|   <SOME: "some">
|   <SQL: "sql">
|   <SQLEXCEPTION: "sqlexception">
|   <SQLSTATE: "sqlstate">
|   <SQLWARNING: "sqlwarning">
|   <START: "start">
|   <STATIC: "static">
|   <SYSTEM: "system">
|   <SYSTEM_USER: "system_user">
|   <TABLE: "table">
|   <TEMPORARY: "temporary">
|   <THEN: "then">
|   <TIMEZONE_HOUR: "timezone_hour">
|   <TIMEZONE_MINUTE: "timezone_minute">
|   <TO: "to">
|   <TRAILING: "trailing">
|   <TRANSLATE: "translate">
|   <TRIGGER: "trigger">
|   <TRUE: "true">
|   <UNION: "union">
|   <UNIQUE: "unique">
|   <UNKNOWN: "unknown">
|   <USER: "user">
|   <UPDATE: "update">
|   <USING: "using">
|   <VALUE: "value">
|   <VALUES: "values">
|   <VIRTUAL: "virtual">
|   <WHEN: "when">
|   <WHENEVER: "whenever">
|   <WHERE: "where">
|   <WITH: "with">
|   <WHILE: "while">
|   <WINDOW: "window">
|   <WITHIN: "within">
|   <WITHOUT: "without">
|   <YEAR: "year">

|   <ALLOCATE: "allocate">
|   <ARE: "are">
|   <ASENSITIVE: "asensitive">
|   <ASYMETRIC: "asymetric">
|   <CYCLE: "cycle">
|   <DEC: "dec">
|   <DEREF: "deref">
|   <DYNAMIC: "dynamic">
|   <ELEMENT: "element">
|   <FREE: "free">
|   <INT: "int">
|   <LATERAL: "lateral">
|   <LOCALTIME: "localtime">
|   <LOCALTIMESTAMP: "localtimestamp">
|   <MEMBER: "member">
|   <MULTISET: "multiset">
|   <NATIONAL: "national">
|   <NCHAR: "nchar">
|   <NCLOB: "nclob">
|   <NUMERIC: "numeric">
|   <RELEASE: "release">
|   <SPECIFICTYPE: "specifictype">
|   <SYMETRIC: "symetric">
|   <SUBMULTILIST: "submultilist">
|   <TRANSLATION: "translation">
|   <TREAT: "treat">
|   <VARYING: "varying">
}

TOKEN : /* SQL/XML Reserved words */
{
    <XMLAGG: "xmlagg">
|   <XMLATTRIBUTES: "xmlattributes">
|   <XMLBINARY: "xmlbinary">
|   <XMLCAST: "xmlcast">
|   <XMLCONCAT: "xmlconcat">
|   <XMLCOMMENT: "xmlcomment">
|   <XMLDOCUMENT: "xmldocument">
|   <XMLELEMENT: "xmlelement">
|   <XMLEXISTS: "xmlexists">
|   <XMLFOREST: "xmlforest">
|   <XMLITERATE: "xmliterate">
|   <XMLNAMESPACES: "xmlnamespaces">
|   <XMLPARSE: "xmlparse">
|   <XMLPI: "xmlpi">
|   <XMLQUERY: "xmlquery">
|   <XMLSERIALIZE: "xmlserialize">
|   <XMLTABLE: "xmltable">
|   <XMLTEXT: "xmltext">
|   <XMLVALIDATE: "xmlvalidate">
}

TOKEN : /* SQL/MED Reserved words */
{
    <DATALINK: "datalink">
|   <DLNEWCOPY: "dlnewcopy">
|   <DLPREVIOUSCOPY: "dlpreviouscopy">
|   <DLURLCOMPLETE: "dlurlcomplete">
|   <DLURLCOMPLETEWRITE: "dlurlcompletewrite">
|   <DLURLCOMPLETEONLY: "dlurlcompleteonly">
|   <DLURLPATH: "dlurlpath">
|   <DLURLPATHWRITE: "dlurlpathwrite">
|   <DLURLPATHONLY: "dlurlpathonly">
|   <DLURLSCHEME: "dlurlscheme">
|   <DLURLSERVER: "dlurlserver">
|   <DLVALUE: "dlvalue">
|   <IMPORT: "import">
}

TOKEN : /* User variables and literals */
{
    < ALL_IN_GROUP: <ID> <PERIOD> <STAR> >

|   < ID: <QUOTED_ID> (<PERIOD> <QUOTED_ID>)* >
|	< #QUOTED_ID: <ID_PART> | ("\"" (("\"\"") | ~["\""] )+ "\"") >           
|   < #ID_PART: (("@" | "#" | <LETTER>) (<LETTER> | "_" | <DIGIT>)*) >               

| 	< DATETYPE: "{" "d" >
| 	< TIMETYPE: "{" "t" >
| 	< TIMESTAMPTYPE: "{" "ts" >
| 	< BOOLEANTYPE: "{" "b" >
|   < POS_REF: ["$"] (<DIGIT>)+ >
|	< INTEGERVAL: (<MINUS>)?(<DIGIT>)+ >
|   < FLOATVAL: (<MINUS>)? (<DIGIT>)* <PERIOD> (<DIGIT>)+ 
				( ["e", "E"] (["+","-"])? (<DIGIT>)+ )? >
|   < STRINGVAL: (("N"|"E")? "'" ( ("''") | ~["'"] )* "'") >
|	< #LETTER: (["a"-"z","A"-"Z"] | ["\u0153"-"\ufffd"]) >
|	< #DIGIT: ["0"-"9"] >

}

TOKEN : /* Punctuation */
{
	<COMMA: ",">
|	<PERIOD: ".">
|	<LPAREN: "(">
|	<RPAREN: ")">
|   <LBRACE: "{">
|   <RBRACE: "}">
|   <LSBRACE: "[">
|   <RSBRACE: "]">
|	<EQ: "=">
|	<NE: "<>">
|	<NE2: "!=">
|	<LT: "<">
|	<LE: "<=">
|	<GT: ">">
|	<GE: ">=">
|	<STAR: "*">
|	<SLASH: "/">
|	<PLUS: "+">
|	<MINUS: "-">
|   <QMARK: "?">
|   <DOLLAR: "$">
|   <SEMICOLON: ";">
|   <COLON: ":">
|	<CONCAT_OP: "||">
}


//----------------------------------------------------
//----------------------------------------------------

String stringVal() :
{
	Token t = null;	
}
{
  	(t = <STRINGVAL>)
  	{
  		return normalizeStringLiteral(t.image);
  	}
}

String id() :
{
	Token t = null;
}
{
  	(t = <ID>)
  	{
  		return normalizeId(t.image);
  	}
}

/** 
 * Parse any of several command types - this is the main parser entry point. 
 * @param info instructions to parse the command
 * @return Parsed command
 * @throws ParseException if parsing failed
 */
CommandImpl command(ParseInfo info) :
{
	CommandImpl command = null;
}
{
	 (LOOKAHEAD(2) command = createUpdateProcedure(info) |
	  command = userCommand(info) |
	  command = callableStatement(info)
	)
	[<SEMICOLON>]
	<EOF>
	{
		return command;
	}
}

CommandImpl designerCommand(ParseInfo info) :
{
	CommandImpl command = null;
}
{
	 (LOOKAHEAD(2) command = updateProcedure(info) |
	  command = userCommand(info)	  
	)
	[<SEMICOLON>]
	<EOF>
	{
		return command;
	}
}

CommandImpl updateProcedure(ParseInfo info) :
{
	CommandImpl command = null;
}
{
	(command = createUpdateProcedure(info) |
	 command = forEachRowTriggerAction(info))
	<EOF>
	{
		return command;
	}
}

CommandImpl createTrigger(ParseInfo info) :
{
  	String target = null;
  	TriggerActionImpl triggerAction = null;
  	Token event = null;
  	
}
{
	<CREATE> <TRIGGER> <ON> target = id() nonReserved("INSTEAD") <OF> 
	(event = <INSERT> | event = <UPDATE> | event = <DELETE>) 
	<AS> triggerAction = forEachRowTriggerAction(info)
	{
		AlterTriggerImpl trigger = alterTrigger();
        trigger.setTarget(groupSymbol(target));
        trigger.setDefinition(triggerAction);
        trigger.setEvent(Table.TriggerEvent.valueOf(event.image.toUpperCase()));
        trigger.setCreate(true);
        return trigger;
	}
}

CommandImpl alter(ParseInfo info) :
{
  	String target = null;
  	QueryCommandImpl command = null;
  	StatementImpl stmt = null;
  	TriggerActionImpl triggerAction = null;
  	Token comment = null;
  	Token event = null;
  	String enabled = null;
}
{
	<ALTER>
	(
	 	(nonReserved("VIEW") target = id() <AS> { comment = getToken(1).specialToken; } command = queryExpression(info)) 
	 	{
	 	    /*
             * if (comment != null) {
             *     command.setCacheHint(getQueryCacheOptionImpl(comment.image));
             * }
             */
	 	    AlterViewImpl view = alterView();
            view.setTarget(groupSymbol(target));
            view.setDefinition(command);
            return view;
	 	}
		| (<PROCEDURE> target = id() <AS> { comment = getToken(1).specialToken; } stmt = statement(info)) 
		{
			CreateUpdateProcedureCommandImpl cup = createASTNode(ASTNodes.CREATE_UPDATE_PROCEDURE_COMMAND);
            cup.setBlock(asBlock(stmt));
			cup.setUpdateProcedure(false);
			/*
             * if (comment != null) {
             *     cup.setCacheHint(getQueryCacheOptionImpl(comment.image));
             * }
             */
			AlterProcedureImpl procedure = alterProcedure();
            procedure.setTarget(groupSymbol(target));
            procedure.setDefinition(cup);
            return procedure;
		}
		| (<TRIGGER> <ON> target = id() nonReserved("INSTEAD") <OF> 
		  (event = <INSERT> | event = <UPDATE> | event = <DELETE>) 
		  ((<AS> triggerAction = forEachRowTriggerAction(info))
		  |enabled = nonReserved("ENABLED","DISABLED")))
		{
		    AlterTriggerImpl trigger = alterTrigger();
            trigger.setTarget(groupSymbol(target));
            trigger.setDefinition(triggerAction);
            trigger.setEvent(Table.TriggerEvent.valueOf(event.image.toUpperCase()));
            if (enabled != null) {
                trigger.setEnabled(enabled.equalsIgnoreCase("ENABLED"));
            }
            return trigger;
		}
	)
}

TriggerActionImpl forEachRowTriggerAction(ParseInfo info) #TriggerActionImpl :
{
	BlockImpl b = block();
	b.setAtomic(true);
	StatementImpl stmt = null;
}
{
	<FOR> <EACH> <ROW>
	(
	 LOOKAHEAD(1) (<BEGIN> [<ATOMIC>]
      (
	    stmt = statement(info)
	    {          
    	    b.addStatement(stmt);            	                	    
	    }
      )*
      <END> 
     )
     |
     stmt = statement(info)
     {
       b = asBlock(stmt);
       b.setAtomic(true);
     }
    ) 
	{
		jjtThis.setBlock(b);
        return jjtThis;
	}
}

CommandImpl userCommand(ParseInfo info) :
{
	CommandImpl command = null;
	SourceHintImpl sourceHint = null;
}
{
    {int index = 1; 
     Token t = null;
     do  
       t = getToken(index++);
     while (t != null && t.kind == LPAREN);
     t = getToken(index);
     if (t != null) 
      sourceHint = getSourceHint(t); 
    }
	(command = queryExpression(info) |
	command = storedProcedure(info, newStoredProcedure()) |
	command = insert(info) |
	command = update(info) |
	command = delete(info) |
	command = dropTable(info) |
	LOOKAHEAD(2) command = createTempTable(info) |
	command = alter(info) |
	command = createTrigger(info)
	)
	{
	    if (sourceHint != null) {
//	        if (command instanceof SetQueryImpl) {//	        	((SetQueryImpl)command).getProjectedQueryImpl().setSourceHint(sourceHint);//	        } else {
	    		command.setSourceHint(sourceHint);
//	    	}
	    }
		return command;
	}
}

/** 
 * Parse drop table command. 
 * @param info instructions to parse the command
 * @return Parsed command
 * @throws ParseException if parsing failed
 */
CommandImpl dropTable(ParseInfo info) #DropImpl :
{
	String table = null;
}
{
	<DROP> <TABLE> 
	table = id()
	{
		jjtThis.setTable(groupSymbol(table));
		return jjtThis;
	}
}

/** 
 * Parse create temp table command. 
 * @param info instructions to parse the command
 * @return Parsed command
 * @throws ParseException if parsing failed
 */
CommandImpl createTempTable(ParseInfo info) #CreateImpl :
{
    String table = null;
    String pkId = null;
    Column col = null;
}
{
    <CREATE> <LOCAL> <TEMPORARY> <TABLE> 
    table = id()
    <LPAREN>
    {
        jjtThis.setTable(groupSymbol(table));
    }
    col = tableElement(info)
    {
      jjtThis.getColumns().add(col);
    }
    (LOOKAHEAD(2) <COMMA>
      col = tableElement(info)
      {
        jjtThis.getColumns().add(col);
      }
    )*  
    [<COMMA> <PRIMARY> nonReserved("KEY") <LPAREN>
      pkId = id()
      {
        jjtThis.getPrimaryKey().add(elementSymbol(validateName(pkId, true)));
      }
      (<COMMA> pkId = id()
       {
         jjtThis.getPrimaryKey().add(elementSymbol(validateName(pkId, true)));
       }
      )*
     <RPAREN>   
    ]
    <RPAREN>
    {
        return jjtThis;
    }
}

Column tableElement(ParseInfo info) :
{
    String element = null;
    String type = null;
    boolean autoIncrement = false;
    boolean notNull = false;
}
{
     element = id()
     (
      type = dataTypeString()
      |
      nonReserved("SERIAL")
      {
        type = "INTEGER";
        autoIncrement = true;
        notNull = true;
      }
     )
     [<NOT> <NULL> { notNull = true; }]
     {
        try {
          Column c = new Column(getVersion());
          c.setName(validateName(element, true));
          c.setRuntimeType(type);
          c.setAutoIncremented(autoIncrement);
          c.setNullType(notNull?NullType.No_Nulls:NullType.Nullable);
          return c;
        } catch (Exception ex) {          throw new ParseException(ex.getLocalizedMessage());
        }
     }
}

/**
 * Parse error statement
 * @throws ParseException if parsing failed
 */
RaiseErrorStatementImpl errorStatement(ParseInfo info) :
{
    BaseExpression errMsg = null;           
}
{ 
    <ERROR>
    errMsg = expression(info)           
        
    {
        RaiseErrorStatementImpl errStmt = raiseErrorStatement(errMsg);       
        return errStmt; 
    }
}

RaiseErrorStatementImpl raiseErrorStatement(BaseExpression expression) #RaiseErrorStatementImpl :
{
}
{
    {
      jjtThis.setExpression(expression);
      return jjtThis;
    }
}

/**
 * Parse statement
 * @throws ParseException if parsing failed
 */
StatementImpl statement(ParseInfo info) :
{
    StatementImpl statement;
    String label = null;
}
{
    (
	 LOOKAHEAD(2) ([label = id() <COLON>] 
	  (
	   statement = loopStatement(info) |
	   statement = whileStatement(info) |
	   statement = compoundStatement(info)
	  )
	  {
	  	((Labeled) statement).setLabel(label);
	  }
	 )
	 |
	 (
      statement = ifStatement(info) |
      statement = delimitedStatement(info)
	 )
	)
    
    {
        return statement;
    }
}

StatementImpl delimitedStatement(ParseInfo info) :
{
    StatementImpl stmt = null;
}           
{
     (LOOKAHEAD(3) stmt = assignStatement(info) |
	  stmt = sqlStatement(info) |
      stmt = errorStatement(info) |
	  stmt = declareStatement(info) |
	  stmt = branchingStatement(info)
	 )
	 <SEMICOLON>
	 {
	     return stmt;
	 }
}

BlockImpl compoundStatement(ParseInfo info) :
{
    StatementImpl stmt = null;  
    BlockImpl block = block();
    Boolean atomic = null;
}
{   
    <BEGIN> [[<NOT> {atomic = Boolean.FALSE;}] <ATOMIC> {if (atomic == null) {atomic = Boolean.TRUE;}}]
    (
      stmt = statement(info)
      {
	    block.addStatement(stmt);            	                	    
	  }
 	)*
    <END>
    {
        if (atomic != null) {
        	block.setAtomic(atomic);
        }
        return block;
    }
}        

/**
 * Parse break statement 
 * @throws ParseException if parsing failed
 */
BranchingStatementImpl branchingStatement(ParseInfo info) #BranchingStatementImpl :
{
    Token mode = null;
    String label = null;
}
{
 	(
 	 (
 	  (mode = <BREAK> | mode = <CONTINUE>) [label = id()] 
 	 )
 	 | 
 	 (mode = <LEAVE> label = id())
 	)
 	{
 	    jjtThis.setMode(BranchingStatementImpl.BranchingMode.valueOf(mode.image.toUpperCase()));
 	    jjtThis.setLabel(label);
 		return jjtThis;
 	}
} 	

/**
 * Parse while statement 
 * @throws ParseException if parsing failed
 */
WhileStatementImpl whileStatement(ParseInfo info) #WhileStatementImpl :
{
    CriteriaImpl criteria = null;
    StatementImpl stmt = null;
}
{
    <WHILE>
    <LPAREN>  
    criteria = criteria(info)
    <RPAREN>
    stmt = statement(info)
    {
        jjtThis.setCondition(criteria);
        jjtThis.setBlock(asBlock(stmt));   
        return jjtThis;
    }    
}    

/**
 * Parse loop statement 
 * @throws ParseException if parsing failed
 */
LoopStatementImpl loopStatement(ParseInfo info) #LoopStatementImpl :
{
    String cursor = null;
    QueryCommandImpl query = null;
    StatementImpl stmt = null;
}
{
    <LOOP>
    <ON>
    <LPAREN>  
    query = queryExpression(info)
    <RPAREN>
    <AS>
    cursor = id()
    stmt = statement(info)
    {
        jjtThis.setBlock(asBlock(stmt));
        jjtThis.setCommand(query);
        jjtThis.setCursorName(cursor);   
        return jjtThis;
    }    
}   

/**
 * Parse if statement 
 * @throws ParseException if parsing failed
 */
IfStatementImpl ifStatement(ParseInfo info) #IfStatementImpl :
{
    CriteriaImpl criteria = null;
    StatementImpl ifStatement = null;
    StatementImpl elseStatement = null;
}
{
    <IF>
    <LPAREN>  
    criteria = criteria(info)
    <RPAREN>
    ifStatement = statement(info)
    //else blocks will be associated with the closest if block
    [LOOKAHEAD(1)<ELSE> elseStatement = statement(info)]
    {
        jjtThis.setCondition(criteria);
        jjtThis.setIfBlock(asBlock(ifStatement));
        jjtThis.setElseBlock(asBlock(elseStatement));
        return jjtThis;
    }    
}    
            
/**
 * Parse criteria selector
 * @throws ParseException if parsing failed
 */
CriteriaSelectorImpl criteriaSelector() #CriteriaSelectorImpl :
{
    String element = null;
    List elements = new ArrayList(2);
    Token operator = null;
}
{
    [(operator = <EQ> |
     operator = <NE> |
     operator = <NE2> |
     operator = <LE> |
     operator = <GE> |
     operator = <LT> |
     operator = <GT> |
     operator = <IN> |
     operator = <LIKE> |
     (operator = <IS> <NULL>) |
     operator = <BETWEEN>)
     {
       jjtThis.setSelectorType(Operator.getOperator(getVersion(), operator.image));
	 }
    ]
         
    <CRITERIA>
     
    [LOOKAHEAD(4)<ON> 
    <LPAREN> 
    
    element = id()
    
    { 
       elements.add(elementSymbol(element));
    }       
        
    (<COMMA>
        element = id()
    
    	{
       		elements.add(elementSymbol(element));
    	}
    )*
    <RPAREN>

	{
       jjtThis.setElements(elements);
    }
   ]
   
   {
       return jjtThis;
   }
} 

/**
 * Parse has criteria
 * @throws ParseException
 */
HasCriteriaImpl hasCriteria() #HasCriteriaImpl :
{
    CriteriaSelectorImpl critSelector = null;
}
{
    <HAS>
    critSelector = criteriaSelector()
    
    {
        jjtThis.setSelector(critSelector);
        return jjtThis;
    }   
}

/**
 * Parse declare statement
 * @throws ParseException if parsing failed
 */
DeclareStatementImpl declareStatement(ParseInfo info) #DeclareStatementImpl :
{
    String var = null;
    ConstantImpl type = null;
    ElementSymbolImpl variableID = null;
    BaseLanguageObject value = null;
}
{
    <DECLARE>
    type = dataType()
    var = id()
    {
        variableID = elementSymbol(var);
    }
    [(nonReserved(":=")|<EQ>)
     value = assignStatementOperand(info)
    ]
    
    {
        jjtThis.setVariable(variableID);
        jjtThis.setVariableType((String) type.getValue());
        if (value instanceof BaseExpression) {
            jjtThis.setExpression((BaseExpression)value);
    	}
    	else if (value instanceof QueryCommandImpl) {
    	    jjtThis.setExpression(scalarSubquery((QueryCommandImpl)value));
    	}
        else {
            jjtThis.setCommand((CommandImpl)value);
        }

        return jjtThis;
    }           
}

/**
 * Parse assignment statement
 * @throws ParseException if parsing failed
 */
AssignmentStatementImpl assignStatement(ParseInfo info) :
{
    BaseLanguageObject value = null;
    String var = null;
    ElementSymbolImpl elementID = null;
}
{
    var = id()
    {
        elementID = elementSymbol(var);
    } 
    (nonReserved(":=")|<EQ>)
    value = assignStatementOperand(info)
        
    {
        return assignmentStatement(elementID, value);
    }
}

/**
 * Parse operand of assignment statement, which can be nested
 * arbitrarily deeply in parentheses.
 * @throws ParseException if parsing failed
 */
BaseLanguageObject assignStatementOperand(ParseInfo info) :
{
    BaseLanguageObject value = null;
}
{

    (
	  LOOKAHEAD(<INSERT><INTO>) (value = insert(info)) | //deprecated
      value = update(info) | //deprecated
      value = delete(info) | //deprecated
      LOOKAHEAD(expression(info)) (value = expression(info)) |      
      value = queryExpression(info) //deprecated should be a scalar subquery
    ) 
        
    {   
        return value;
    }    
}

/**
 * Parse sql statement 
 * @throws ParseException if parsing failed
 */
CommandStatementImpl sqlStatement(ParseInfo info) #CommandStatementImpl :
{
    CommandImpl cmd = null;
    String var = null;
    ElementSymbolImpl elementID = null;
    StoredProcedureImpl storedProcedure = null;
}
{
    (LOOKAHEAD(2) (cmd = userCommand(info)) |
     cmd = dynamicCommand(info) |
     (
      var = id()
      {
        storedProcedure = newStoredProcedure();
        elementID = elementSymbol(var);
        SPParameterImpl parameter = new SPParameterImpl(this, 1, SPParameterImpl.RETURN_VALUE, "return"); //$NON-NLS-1$
        parameter.setExpression(elementID);
	    storedProcedure.addParameter(parameter);  
	    storedProcedure.setCalledWithReturn(true);            
      } 
      (nonReserved(":=")|<EQ>)
      cmd = storedProcedure(info, storedProcedure) 
     )
    )
  
    {
        jjtThis.setCommand(cmd);
        return jjtThis;
    }
}
 
TranslateCriteriaImpl translateCriteria(ParseInfo info) #TranslateCriteriaImpl :
{
    String element = null;
    BaseExpression value = null;
    ElementSymbolImpl leftSymbol = null;
    
    CriteriaSelectorImpl critSelector = null;      
    
    CompareCriteriaImpl compCrit = null;
    
    List critList = null;
}
{
    
    <TRANSLATE>    
        critSelector = criteriaSelector()

        [<WITH>
         {
            critList = new ArrayList(2);
         }
         <LPAREN>
        element = id()
        <EQ>
        value = expression(info) 
        {
            compCrit = createASTNode(ASTNodes.COMPARE_CRITERIA);
            leftSymbol = elementSymbol(element);
            compCrit.setLeftExpression(leftSymbol);
            compCrit.setRightExpression(value);
            compCrit.setOperator(Operator.EQ);  
            critList.add(compCrit);
            compCrit = null;
        }
        (   <COMMA>
            element = id()
            <EQ>
            value = expression(info)
         {
            compCrit = createASTNode(ASTNodes.COMPARE_CRITERIA);
            leftSymbol = elementSymbol(element);
            compCrit.setLeftExpression(leftSymbol);
            compCrit.setRightExpression(value);
            compCrit.setOperator(Operator.EQ);
            critList.add(compCrit); 
            compCrit = null; 
         }  
       )*
       <RPAREN> 
       ]
            
    {
        jjtThis.setSelector(critSelector);
        
        if ( critList != null) {
            jjtThis.setTranslations(critList);
        }

        return jjtThis;
    }   
}

/**
 * Parse create update procedure command
 * @throws ParseException if parsing failed
 */
CreateUpdateProcedureCommandImpl  createUpdateProcedure(ParseInfo info) #CreateUpdateProcedureCommandImpl :
{
    StatementImpl stmt = null;  
}
{ 
    <CREATE> [<VIRTUAL> {jjtThis.setUpdateProcedure(false);}] 
    [<UPDATE>] 
    <PROCEDURE>

    stmt = statement(info)
    {        
        jjtThis.setBlock(asBlock(stmt));
        return jjtThis;        
    }    
}   

/**
 * Parse error statement
 * @throws ParseException if parsing failed
 */
DynamicCommandImpl dynamicCommand(ParseInfo info) #DynamicCommandImpl :
{
    BaseExpression sql = null;           
    String groupID = null;
	GroupSymbolImpl group = null;
	int updateCount = 0;
	Token updateToken = null;
	List<ProjectedColumnImpl> elements = null;
	SetClauseListImpl using = null;
	SetClauseListImpl setClauseList = null;
}
{ 
    (<EXECUTE>|<EXEC>) [(<STRING>|<IMMEDIATE>)]
    sql = expression(info)
    {
        jjtThis.setSql(sql);
    }
    [<AS> 
	elements = createElementsWithTypes(info)

	 [<INTO>
      groupID = id()
      {
         group = groupSymbol(groupID);
      }
     ]
     {
         jjtThis.setIntoGroup(group);
         List<ElementSymbolImpl> symbols = new ArrayList(elements.size());
         for (ProjectedColumnImpl col : elements) {
         	symbols.add(col.getSymbol());
         }
         jjtThis.setAsColumns(symbols);
         jjtThis.setAsClauseSet(true);
     }
	]
    [<USING>
     using = setClauseList(true, info)
	 {
	     jjtThis.setUsing(using);
	 }
    ]
    [<UPDATE>
     ((updateToken = <INTEGERVAL>) 
     {
        updateCount = Integer.parseInt(updateToken.image);
     }
     |
     (<STAR>) 
     {	
        updateCount = 2;
     })
    ]
    {
        jjtThis.setUpdatingModelCount(updateCount);
        return jjtThis; 
    }
}

SetClauseListImpl setClauseList(boolean shortName, ParseInfo info) #SetClauseListImpl :
{
	String element = null;
	String symbolName = null;
	ElementSymbolImpl symbol = null;
	BaseExpression value = null;
}
{
	element = id()
    <EQ>
    {
        try {
    	   symbolName = shortName?validateName(element, true):element;
           symbol = elementSymbol(symbolName);
           value = expression(info);
           jjtThis.addClause(setClause(symbol, value));
        } catch (Exception ex) {
           throw new ParseException(ex.getLocalizedMessage());
        }
    }
	(<COMMA>
	 element = id()
     <EQ>
     {
        try {
	       symbolName = shortName?validateName(element, true):element;
           symbol = elementSymbol(symbolName);
           value = expression(info);
           jjtThis.addClause(setClause(symbol, value));
        } catch (Exception ex) {
           throw new ParseException(ex.getLocalizedMessage());
        }
     }
	)*
	{
		return jjtThis;
	}
}

SetClauseImpl setClause(ElementSymbolImpl symbol, BaseExpression value) #SetClauseImpl :
{
}
{
    {
        jjtThis.setSymbol(symbol);
        jjtThis.setValue(value);
        return jjtThis;
    }
}

/**
 * Create elements with datatypes
 * @throws ParseException if parsing failed
 */
List<ProjectedColumnImpl> createElementsWithTypes(ParseInfo info) :
{
	String element = null;
	String type = null;
	ProjectedColumnImpl symbol = null;
	List<ProjectedColumnImpl> elements = new ArrayList<ProjectedColumnImpl>();
}
{
	 element = id()
	 type = dataTypeString()
	 {
	    try {
	       symbol = projectedColumn(validateName(element, true), type);
	       elements.add(symbol);
	    } catch (Exception ex) {	       throw new ParseException(ex.getLocalizedMessage());
	    }
	 }
	 (LOOKAHEAD(2) <COMMA>
		element = id()
		type = dataTypeString()
		{
		  try {
	          symbol = projectedColumn(validateName(element, true), type);
		      elements.add(symbol);
		  } catch (Exception ex) {
              throw new ParseException(ex.getLocalizedMessage());
          }
		}
	 )*
	 {
	 	return elements;
	 }
}

ProjectedColumnImpl projectedColumn(String name, String type) #ProjectedColumnImpl :
{
}
{
    {
        jjtThis.setName(name);
        jjtThis.setType(type);
        return jjtThis;
    }
}

StoredProcedureImpl callableStatement(ParseInfo info) :
{
	StoredProcedureImpl storedProcedure = newStoredProcedure();
	storedProcedure.setCallableStatement(true);
	Token call = null;
	String procName = null;
	OptionImpl option = null;
	SPParameterImpl parameter = null;
	int parameterIndex = 1;
}
{
	<LBRACE>
	[<QMARK> <EQ>
	 {
	   parameter = new SPParameterImpl(this, parameterIndex++, SPParameterImpl.RETURN_VALUE, "return"); //$NON-NLS-1$
	   storedProcedure.addParameter(parameter);
	   storedProcedure.setCalledWithReturn(true);
	 }
	]
	<CALL> procName = id()
	{
		storedProcedure.setProcedureName(procName);
	}
		
	//parameters
		
	[<LPAREN>
		
	 (
		  storedProcedure = executeUnnamedParams(info, storedProcedure, parameterIndex)
	 ) 
	 <RPAREN>
	]
	<RBRACE>			
	[option = option(info)
	 {
	   storedProcedure.setOption(option);
	 }
	]

	{
		return storedProcedure;
	}
}


/**
 * * Parse stored query command
 * @throws ParseException if parsing failed
 */
StoredProcedureImpl storedProcedure(ParseInfo info, StoredProcedureImpl storedProcedure) :
{
	String procName = null;
	OptionImpl option = null;
}
{
	(
		(<EXEC> | <EXECUTE> | <CALL>)
		procName = id()
		{
			storedProcedure.setProcedureName(procName);
		}
		
		//parameters
		<LPAREN>
		
		(
		 LOOKAHEAD(<ID> <EQ>)
		 storedProcedure = executeNamedParams(info, storedProcedure)
		 | 		
		 storedProcedure = executeUnnamedParams(info, storedProcedure, storedProcedure.getParameterCount() + 1)
		)
		
		<RPAREN>
	)
	[option = option(info)
	 {
	   storedProcedure.setOption(option);
	 }
	]
	{
		return storedProcedure;
	}
}

StoredProcedureImpl newStoredProcedure() #StoredProcedureImpl :
{
}
{
    {
        return jjtThis;
    }
}

/**
 * <p>Parse an exec statement with unnamed parameters</p>
 * @throws ParseException if parsing failed
 */
StoredProcedureImpl executeUnnamedParams(ParseInfo info, StoredProcedureImpl storedProcedure, int parameterIndex) :
{
	SPParameterImpl parameter = null;
    BaseExpression value = null;	
}
{

	(value = expression(info)
		{
				parameter = new SPParameterImpl(this, parameterIndex++, value);
				parameter.setParameterType(SPParameterImpl.IN);
				storedProcedure.addParameter(parameter);
		}
		(	<COMMA>
			value = expression(info)
			{
					parameter = new SPParameterImpl(this, parameterIndex++, value);
					parameter.setParameterType(SPParameterImpl.IN);
					storedProcedure.addParameter(parameter);
			}
		)*
	)?
	{
		return storedProcedure;
	}
}

/**
 * <p>Parse an exec statement with named parameters</p>
 * @throws ParseException if parsing failed
 */
StoredProcedureImpl executeNamedParams(ParseInfo info, StoredProcedureImpl storedProcedure) :
{
	String name = null;
    BaseExpression value = null;
	SPParameterImpl parameter = null;
	int parameterIndex = 1;
}
{
	{
		storedProcedure.setDisplayNamedParameters(true);
	}
	(name=id()
	 <EQ> [<GT>]
	 value = expression(info)
		{
			parameter = new SPParameterImpl(this, parameterIndex++, value);
			parameter.setName(name);
			parameter.setParameterType(SPParameterImpl.IN);
			storedProcedure.addParameter(parameter);
			parameter = null;
		}
		(	<COMMA>
		 	name=id()
	 		<EQ> [<GT>]
	 		value = expression(info)
			{
				parameter = new SPParameterImpl(this, parameterIndex++, value);
				parameter.setName(name);
				parameter.setParameterType(SPParameterImpl.IN);
				storedProcedure.addParameter(parameter);
				parameter = null;
			}
		)*
	)
	{
		
		return storedProcedure;
	}
}

/**
 * Parse an INSERT command
 * @return Parsed insert statement
 * @throws ParseException if parsing failed
 */
InsertImpl insert(ParseInfo info) #InsertImpl :
{
	String group = null;
	List values = null;
	List<ElementSymbolImpl> columns = null;
	OptionImpl option = null;
	QueryCommandImpl query = null;
}
{
	<INSERT> <INTO>
	group = id()

	[LOOKAHEAD(<LPAREN><ID>) columns = columnList(false) {
	  jjtThis.setVariables(columns);
	}]

	(
		( <VALUES> <LPAREN>
		  values = expressionList(info)
		  <RPAREN>
		  {
		    // Store each row of values
		    jjtThis.setValues(values);
		  }
		)
		|
		( query = queryExpression(info)
		  {
		    jjtThis.setQueryExpression(query);
		  }
		)
	)
	
	[ option = option(info)
	  {
	    jjtThis.setOption(option);
	  }
	]
	
	{
		// Store group
		jjtThis.setGroup(groupSymbol(group) );

		return jjtThis;
	}
}

List<ElementSymbolImpl> columnList(boolean validate) :
{
	String element = null;
	List<ElementSymbolImpl> symbols = new LinkedList<ElementSymbolImpl>();
}
{
   <LPAREN>
	element = id()
	{
		if (validate) {
		    try {
			    element = validateName(element, true);
			} catch (Exception ex) {
                throw new ParseException(ex.getLocalizedMessage());
            }
		}
		symbols.add(elementSymbol(element));
	}
	(	<COMMA>
		element = id()
		{
			if (validate) {
			    try {
				    element = validateName(element, true);
				} catch (Exception ex) {
                    throw new ParseException(ex.getLocalizedMessage());
                }
			}
			symbols.add(elementSymbol(element));
		}
	)*
	<RPAREN>
	{
		return symbols;
	}
}

/**
 * Parse row values - this is a comma separated list of values.
 * @return List of values, never null
 * @throws ParseException if parsing failed
 */
ArrayList<BaseExpression> expressionList(ParseInfo info) :
{
	ArrayList<BaseExpression> rowVals = new ArrayList<BaseExpression>(4);
	BaseExpression value = null;
}
{
	value = expression(info)
	{
        rowVals.add(value);
	}
	(	<COMMA>
	    value = expression(info)
	    {
            rowVals.add(value);
	    }
	)*
	{
		return rowVals;
	}
}

/**
 * Parse an UPDATE command
 * @return Parsed update statement
 * @throws ParseException if parsing failed
 */
UpdateImpl update(ParseInfo info) #UpdateImpl :
{
	String group = null;
	SetClauseListImpl setClauseList = null;
	CriteriaImpl criteria = null;
	OptionImpl option = null;
}
{
	<UPDATE>
	group = id()
	<SET>
	setClauseList = setClauseList(false, info)
	{
		jjtThis.setChangeList(setClauseList);
	}
	[ criteria = where(info) ]
	[option = option(info)
	  {
	   jjtThis.setOption(option);
	  }
	]
	{	
		// Store group
		jjtThis.setGroup(groupSymbol( group) );
		
		// Store optional criteria
		if(criteria != null) {
			jjtThis.setCriteria(criteria);
		}
		
		return jjtThis;
	}
}


/**
 * Parse a DELETE command
 * @return Parsed delete statement
 * @throws ParseException if parsing failed
 */
DeleteImpl delete(ParseInfo info) #DeleteImpl :
{
	String group = null;
	CriteriaImpl criteria = null;
	OptionImpl option = null;
}
{
	<DELETE> <FROM>
	group = id()
	[criteria = where(info)]
	[option = option(info)
	  {
	   jjtThis.setOption(option);
	  }
	]
	{
		jjtThis.setGroup(groupSymbol(group));
		jjtThis.setCriteria(criteria);
		        
        return jjtThis;
	}
}

QueryCommandImpl queryExpression(ParseInfo info) :
{
    QueryCommandImpl queryCommand = null;
	List<WithQueryCommandImpl> withList = null;
	WithQueryCommandImpl withQueryCommand = null;
}
{
	[<WITH> withQueryCommand = withListElement(info)
	  {
	    withList = new LinkedList<WithQueryCommandImpl>();
	    withList.add(withQueryCommand);
	  }
	  (	<COMMA>
	    withQueryCommand = withListElement(info)
	    {
            withList.add(withQueryCommand);
	    }
	  )*
	]
	queryCommand = queryExpressionBody(info)
	{
		queryCommand.setWith(withList);
		return queryCommand;
	}
}

WithQueryCommandImpl withListElement(ParseInfo info) #WithQueryCommandImpl :
{
   String name = null;
   List<ElementSymbolImpl> columns = null;
   QueryCommandImpl queryExpression = null;
}
{
	name = id()
	[ columns = columnList(true)] 
	<AS> <LPAREN> queryExpression = queryExpression(info) <RPAREN>
	{
	    try {
	       jjtThis.setGroupSymbol(groupSymbol(validateName(name, false)));
	    } catch (Exception ex) {
           throw new ParseException(ex.getLocalizedMessage());
        }
        jjtThis.setColumns(columns);
        jjtThis.setQueryExpression(queryExpression);
        return jjtThis;
	}
}

QueryCommandImpl queryExpressionBody(ParseInfo info) :
{
    QueryCommandImpl query = null;
    QueryCommandImpl rightQueryImpl = null;
    boolean all = false;
    OptionImpl option = null;
	OrderByImpl orderby = null;
	LimitImpl limit = null;
	SetQueryImpl.Operation type;
}
{
	query = queryTerm(info) 
	(	(LOOKAHEAD( <UNION>, { getToken(2).kind != JOIN } ) <UNION> { type = SetQueryImpl.Operation.UNION; } | <EXCEPT> { type = SetQueryImpl.Operation.EXCEPT; }) 
 	 	[<ALL> { all = true; } | <DISTINCT>]
 	 	rightQueryImpl = queryTerm(info)
 	   	{
 	   	    query = setQuery(type, all, query, rightQueryImpl);
    		all = false;
	   	}
	) *
    [orderby  = orderby(info) {query.setOrderBy( orderby );}]
    [limit    = limit(info) {query.setLimit( limit );}]
    [LOOKAHEAD(<OPTION>) option = option(info) { query.setOption(option);  }	]
    {
		return query;
    }    
}

QueryCommandImpl queryTerm(ParseInfo info) :
{
    QueryCommandImpl query = null;
    QueryCommandImpl rightQueryImpl = null;
    boolean all = false;
}
{
	query=queryPrimary(info) 
	(	<INTERSECT> 
 		[<ALL> { all = true; } | <DISTINCT>] 
 		rightQueryImpl=queryPrimary(info)
 		{
 		    query = setQuery(SetQueryImpl.Operation.INTERSECT, all, query, rightQueryImpl);
    		all = false;
 		}
	) *
    {
        return query;
    }
}    

SetQueryImpl setQuery(SetQueryImpl.Operation operation, boolean all, QueryCommandImpl leftQueryImpl, QueryCommandImpl rightQueryImpl) #SetQueryImpl :
{
}
{
    {
        jjtThis.setOperation(operation);
        jjtThis.setAll(all);
        jjtThis.setLeftQuery(leftQueryImpl);
        jjtThis.setRightQuery(rightQueryImpl);
        return jjtThis;
    }
}

QueryCommandImpl queryPrimary(ParseInfo info) :
{
    QueryCommandImpl query = null;
    String name = null;
}
{
    (
        query=query(info) | 
        (<TABLE> name=id() {
           MultipleElementSymbolImpl multipleElementSymbol = createASTNode(ASTNodes.MULTIPLE_ELEMENT_SYMBOL);

           SelectImpl select = createASTNode(ASTNodes.SELECT);
           select.setSymbols(Arrays.asList(multipleElementSymbol));

           UnaryFromClauseImpl unaryFromClauseImpl = createASTNode(ASTNodes.UNARY_FROM_CLAUSE);
           unaryFromClauseImpl.setGroup(groupSymbol(name));

           FromImpl from = createASTNode(ASTNodes.FROM);
           from.setClauses(Arrays.asList(unaryFromClauseImpl));
           
           QueryImpl q = createASTNode(ASTNodes.QUERY);
           q.setSelect(select);
           q.setFrom(from);
           query = q;
        }) |
        (<LPAREN> query=queryExpressionBody(info) <RPAREN>)
    )    
    {
        return query;
    }
}    

/**
 * Parse a SELECT query
 * @return Parsed query
 * @throws ParseException if parsing failed
 */
QueryImpl query(ParseInfo info) #QueryImpl :
{
	SelectImpl   select         = null;
	FromImpl     from           = null;
	IntoImpl 	 into			= null;
	CriteriaImpl criteria       = null;
	GroupByImpl  groupBy        = null;
	CriteriaImpl having         = null;	
}
{
    select	  = select(info)
    [into	  = into(info)]
   	[from 	  = from(info)
   		
    [criteria = where(info)]
    [groupBy  = groupBy(info)]
    [having   = having(info)]]

	{
		// Build query from parsed pieces
		jjtThis.setSelect( select );
		jjtThis.setFrom( from );
		jjtThis.setInto( into );
		jjtThis.setCriteria(criteria);
		jjtThis.setGroupBy(groupBy);
		jjtThis.setHaving(having);

		return jjtThis;
  	}
}

IntoImpl into(ParseInfo info) #IntoImpl :
{
	String groupID = null;
}
{	
	<INTO>
	(groupID=id())
	{
    	jjtThis.setGroup(groupSymbol(groupID));
        return jjtThis;
    }	
}

/**
 * <p>Parse a SELECT clause.  The select must handle elements, aliased elements
 * (x AS y), group.*, and *.  It also must handle an optional DISTINCT at the
 * beginning of the select list.  It also must handle a scalar subquery expression
 * in parentheses.</p>
 * <p>Example:  "SELECT group.element, group2.element2 AS x, group3.*". </p>
 * <p>Example:  "SELECT *". </p>
 * <p>Example:  "SELECT DISTINCT a, b, c".</p>
 * <p>Example:  "SELECT a, (SELECT b FROM groupC)".</p>
 * <p>Example:  "SELECT a, (SELECT b FROM groupC) as d".</p>
 * @return Parsed select
 * @throws ParseException if parsing failed
 */
SelectImpl select(ParseInfo info) #SelectImpl :
{
	boolean isDistinct = false;		// unless DISTINCT keyword in SELECT
	BaseExpression symbol = null;
}
{
	<SELECT>
	[<ALL> | (<DISTINCT> {isDistinct=true;})]
	(<STAR>
		{
		    MultipleElementSymbolImpl multipleElementSymbol = createASTNode(ASTNodes.MULTIPLE_ELEMENT_SYMBOL);
            jjtThis.addSymbol(multipleElementSymbol);
		}
	|
		(	symbol=selectSymbol(info)      { jjtThis.addSymbol(symbol); }
		    (	<COMMA>
				symbol=selectSymbol(info)  { jjtThis.addSymbol(symbol); }
			)*		
		)
	)		
	{
 		jjtThis.setDistinct(isDistinct);
		return jjtThis;
	}
}

BaseExpression selectSymbol(ParseInfo info) :
{
	BaseExpression symbol = null;	
}
{
	(
		symbol = selectExpression(info)
		|
		symbol = allInGroupSymbol()
	)
	{
		return symbol;
	}
}

SingleElementSymbol selectExpression(ParseInfo info) :
{
	BaseExpression expression = null;
    String alias = null;
}
{
	(	
		// BaseExpression
		expression=expression(info)	
		[[<AS>] alias=id() ]
	)
	{		
		SingleElementSymbol es = null;
		if(!(expression instanceof SingleElementSymbol)) {
			String functionName = generateFunctionName(info, null);
			ExpressionSymbolImpl expressionSymbol = expressionSymbol();
			expressionSymbol.setName(functionName);
			expressionSymbol.setExpression(expression);
			es = expressionSymbol;
		} else {
		    es = (SingleElementSymbol)expression;
		}
		if(alias != null) {
		    try {
			    alias = validateName(alias, false);
			} catch (Exception ex) {
                throw new ParseException(ex.getLocalizedMessage());
            }
			return aliasSymbol(alias, es);
		}
		return es;
	}
}

DerivedColumnImpl derivedColumn(ParseInfo info) #DerivedColumnImpl :
{
	BaseExpression expression = null;
    String alias = null;
}
{
	(	
		// BaseExpression
		expression=expression(info)	
		[<AS> alias=id() ]
	)
	{		
		if(alias != null) {
		    try {
			    alias = validateName(alias, false);
			} catch (Exception ex) {
                throw new ParseException(ex.getLocalizedMessage());
            }
		}
		jjtThis.setAlias(alias);
        jjtThis.setExpression(expression);
        return jjtThis;
	}
}

MultipleElementSymbolImpl allInGroupSymbol() #MultipleElementSymbolImpl :
{
	Token allInGroupToken = null;
	
}
{
   	allInGroupToken = <ALL_IN_GROUP>    
    {
        String name = normalizeId(allInGroupToken.image.substring(0, allInGroupToken.image.length() - 2));
		jjtThis.setName(name);
        return jjtThis;
	}
}

BaseAggregateSymbol orderedAgg(ParseInfo info) :
{
    Token t = null;
	BaseExpression expression = null;
	OrderByImpl orderBy = null;
	BaseExpression condition = null;
}
{
	(t=<XMLAGG>|t=<ARRAY_AGG>)
	<LPAREN>
	expression = expression(info)
	[ orderBy = orderby(info) ]
	<RPAREN>
	condition = filterClause(info)
	{
		String aggName = t.image.toUpperCase();
		String name = generateFunctionName(info, aggName);
		BaseAggregateSymbol	agg = newBaseAggregateSymbol(name, aggName, false, expression);
		agg.setOrderBy(orderBy);
		agg.setCondition(condition);
		return agg;
	}
}

BaseAggregateSymbol textAgg(ParseInfo info) :
{
	DerivedColumnImpl expression = null;
	Character delimiter = null;
	Character quote = null;
	boolean header = false;	
	List<DerivedColumnImpl> expressions = new ArrayList<DerivedColumnImpl>();
	OrderByImpl orderBy = null;
	String encoding = null;
	BaseExpression condition = null;
}
{
	nonReserved("TEXTAGG") <LPAREN>
	<FOR> expression = derivedColumn(info)
	{
		expressions.add(expression);
	}
	(<COMMA>
		expression = derivedColumn(info)
		{
			expressions.add(expression);
		}
	)* 		
	[
	  LOOKAHEAD(<ID>, { "delimiter".equalsIgnoreCase(getToken(1).image) }) <ID>
	  delimiter = charVal(info, "DELMITER")
	]
	[
	  LOOKAHEAD(<ID>, { "quote".equalsIgnoreCase(getToken(1).image) })
	  ( <ID> quote = charVal(info, "QUOTE") )
	]
	[
	  LOOKAHEAD(<ID>, { "header".equalsIgnoreCase(getToken(1).image) }) <ID>
	  { header = true; }
	]	
	[
	  LOOKAHEAD(<ID>, { "encoding".equalsIgnoreCase(getToken(1).image) })
	  ( <ID> encoding = id() )
	]
	[
		orderBy = orderby(info)
	]	
	<RPAREN>
	condition = filterClause(info)
	{
		TextLineImpl tf = textLine();
		tf.setDelimiter(delimiter);
		tf.setQuote(quote);
		tf.setIncludeHeader(header);
		tf.setExpressions(expressions);
		tf.setEncoding(encoding);
        String name = generateFunctionName(info, "TEXTAGG");
		BaseAggregateSymbol agg = newBaseAggregateSymbol(name, "TEXTAGG", false, tf);
		agg.setOrderBy(orderBy);
		agg.setCondition(condition);
		return agg;
	}
}

BaseAggregateSymbol aggregateSymbol(ParseInfo info) :
{
	String func = null;
	Token starToken = null;
	BaseAggregateSymbol agg = null;
	boolean isDistinct = false;
	BaseExpression expression = null;
	BaseExpression condition = null;
}
{
	(
		// COUNT(*)
		(LOOKAHEAD(3) (
			func = nonReserved("COUNT")
			<LPAREN>
			starToken = <STAR>
			<RPAREN> )	|
		LOOKAHEAD(<ID>, {matchesAny(getToken(1).image, "rank", "dense_rank", "row_number") != null}) (func = nonReserved("row_number", "rank", "dense_rank", "percent_rank", "cume_dist")
			<LPAREN> <RPAREN>) |
		// Remaining aggregates
		(	(func = nonReserved("COUNT", "SUM", "AVG", "MIN", "MAX", "EVERY", "STDDEV_POP", "STDDEV_SAMP", "VAR_SAMP", "VAR_POP") 
				|
				<ANY> { func = "ANY"; }
				|
				<SOME> { func = "SOME"; }
			)
			<LPAREN>
			[ <DISTINCT> {isDistinct=true;} | <ALL>]
			expression = expression(info)
			<RPAREN>
		)) 
		condition = filterClause(info)
	)
	{
		func = func.toUpperCase();
		String name = generateFunctionName(info, func);
		if(starToken == null) { 
			// Aggregate
			agg = newBaseAggregateSymbol(name, func, isDistinct, expression);
		} else {
			// COUNT(*)			
			agg = newBaseAggregateSymbol(name, func, false, null);
		}
		agg.setCondition(condition);
		return agg;
	}
}

BaseExpression filterClause(ParseInfo info) :
{
	BaseExpression condition = null;
}
{
	[ <FILTER> <LPAREN> <WHERE> condition = booleanPrimary(info) <RPAREN> ]
	{
		return condition;	
	}
}

/**
 * <p>Parse a FROM.  The from must handle groups, aliased groups or
 * joined groups. This also handles JDBC escape processinf syntax for outer joins.</p>
 * <p>Example:  "FROM a, b". </p>
 * <p>Example:  "FROM a AS x, b as Y". </p>
 * <p>Example:  "FROM a right outer join b, c, d join e".</p>
 * @param from object which is to be updated with the details in the from clause.
 * @return list containing criteria objects.
 * @throws ParseException if parsing failed
 */
FromImpl from(ParseInfo info) #FromImpl :
{
	FromClauseImpl clause = null;
	List clauseList = new LinkedList();
}
{
	<FROM>
	(	clause = tableReference(info)
		{
			clauseList.add(clause);
			clause = null;
		}
		
		(<COMMA> clause = tableReference(info)
			{
				clauseList.add(clause);
				clause = null;
			}
		)*
	) 

	{
		jjtThis.setClauses(clauseList);
        return jjtThis;
	}
}

/**
 * <p>Parse a join predicate clause, which occurs as an element in the FROM clause.  
 * The join predicate combines two from clauses with a join.</p>
 * @return Join predicate
 * @throws ParseException if parsing failed
 */
FromClauseImpl tableReference(ParseInfo info) :
{
    FromClauseImpl fromClause = null;
}
{	
	(
		(	
			<LBRACE> nonReserved("OJ")
			fromClause=joinedTable(info)
			<RBRACE>
		) 
		|
		fromClause=joinedTable(info)
	)
	{
		return fromClause;
	}
}	

FromClauseImpl joinedTable(ParseInfo info) :
{
	FromClauseImpl result = null;
	JoinPredicateImpl jp = null;
}
{
	result = tablePrimary(info) /* this is a fix for left recursion in the spec */
	( LOOKAHEAD(2)	
		(	jp = crossJoin(info)
			| jp = qualifiedJoin(info)
		)
		{
			jp.setLeftClause(result);
			result = jp;
		}
	) *
	{
		return result;
	}
}

JoinPredicateImpl crossJoin(ParseInfo info) :
{
	JoinPredicateImpl result;
	FromClauseImpl clause = null;
}
{
    {
        result = joinPredicate();
    }
	(	(<CROSS> {result.setJoinType(joinType(JoinTypeTypes.JOIN_CROSS));}|<UNION> {result.setJoinType(joinType(JoinTypeTypes.JOIN_UNION));})
    	<JOIN> 
		clause = tablePrimary(info) {result.setRightClause(clause);}
	)
	{
		return result;
	}
}

JoinPredicateImpl qualifiedJoin(ParseInfo info) :
{
	JoinPredicateImpl result;
	FromClauseImpl clause = null;
	CriteriaImpl onCriteria = null;
}
{
    {
        result = joinPredicate();
    }
	(	[	(<RIGHT> {result.setJoinType(joinType(JoinTypeTypes.JOIN_RIGHT_OUTER));} [<OUTER>])
    		| (<LEFT> {result.setJoinType(joinType(JoinTypeTypes.JOIN_LEFT_OUTER));} [<OUTER>])
    		|  (<FULL> {result.setJoinType(joinType(JoinTypeTypes.JOIN_FULL_OUTER));} [<OUTER>])
    		| <INNER>
		]
		<JOIN>
		clause = tableReference(info) {result.setRightClause(clause);}
		<ON>
		onCriteria = criteria(info) {result.setJoinCriteria(CriteriaImpl.separateCriteriaByAnd(onCriteria));}
	)
	{
		return result;
	}
}

JoinPredicateImpl joinPredicate() #JoinPredicateImpl :
{
}
{
    {
        return jjtThis;
    }
}

JoinTypeImpl joinType(JoinTypeTypes kind) #JoinTypeImpl :
{
}
{
    {
        jjtThis.setKind(kind);
        return jjtThis;
    }
}

FromClauseImpl tablePrimary(ParseInfo info) :
{
	FromClauseImpl clause = null;
	Token lparen = null;
}
{
	(	LOOKAHEAD(<ID> <LPAREN>, { "texttable".equalsIgnoreCase(getToken(1).image) }) clause = textTable(info)
	    |
	    LOOKAHEAD(<ID> <LPAREN>, { "arraytable".equalsIgnoreCase(getToken(1).image) }) clause = arrayTable(info)
	    |
	    clause = xmlTable(info)
	    |
	    clause = unaryFromClauseImpl(info)
		|
		LOOKAHEAD(subqueryFromClauseImpl(info)) clause = subqueryFromClauseImpl(info) 
	    |			
		(lparen = <LPAREN> clause = joinedTable(info) 
		 {
			setFromClauseOptions(lparen, clause);
		 }
		 <RPAREN> 
		)
	)
	[	(<MAKEDEP>  { clause.setMakeDep(true); })
	 	| (<MAKENOTDEP> {  clause.setMakeNotDep(true); } )
	]
	{
		return clause;
	}
}

XMLSerializeImpl xmlSerialize(ParseInfo info) #XMLSerializeImpl :
{
	BaseExpression expr = null;
	String doc = null;
	Token t = null;
}
{
	<XMLSERIALIZE> <LPAREN>
	[LOOKAHEAD(<ID>, {matchesAny(getToken(1).image, "document", "content") != null}) doc = nonReserved("DOCUMENT", "CONTENT")]
	expr = expression(info)
	[
		<AS> (t = <STRING> | t = <VARCHAR> | t = <CLOB>)
	]
	<RPAREN>
	{
		jjtThis.setExpression(expr);
		if (doc != null) {
			jjtThis.setDocument("document".equalsIgnoreCase(doc));
		}
		if (t != null) {
			jjtThis.setTypeString(t.image);
		}
		return jjtThis;
	}
}

String nonReserved(String... expected) :
{
	Token t = null;
}
{
	t = <ID> 
	{
		String result = matchesAny(t.image, expected);
		if (result != null) {
			return result;
		}
		throw new ParseException(Messages.getString(Messages.TeiidParser.expected_non_reserved, Arrays.toString(expected), t.image));
	}
}

ArrayTableImpl arrayTable(ParseInfo info) #ArrayTableImpl :
{
	BaseExpression array = null;
	List<ProjectedColumnImpl> columns;
	String aliasID = null;
}
{
 	<ID> <LPAREN> array = expression(info)
 	nonReserved("COLUMNS")
 	columns = createElementsWithTypes(info) 
 	<RPAREN>
 	[<AS>] aliasID=id()
 	{
 		jjtThis.setArrayValue(array);
        jjtThis.setColumns(columns);
        jjtThis.setName(aliasID);
        return jjtThis;
 	}
}

TextTableImpl textTable(ParseInfo info) #TextTableImpl :
{
	BaseExpression file = null;
	TextColumnImpl column = null;
	List<TextColumnImpl> columns = new ArrayList<TextColumnImpl>();
	boolean useRowDelimiter = true;
	Character delimiter = null;
	boolean escape = false;
	Character quote = null;
	Integer header = null;
	Integer skip = null;
	String aliasID = null;
}
{
 	<ID> <LPAREN> file = expression(info)
 	nonReserved("COLUMNS")
 	column = textColumn(info)
	{
		columns.add(column);
	} 
	(<COMMA>
		column = textColumn(info)
		{
			columns.add(column);
		}
	)* 
	[
	  <NO> <ROW> nonReserved("DELIMITER")
	  {
	    useRowDelimiter = false;
	  }
	]
	[
	  LOOKAHEAD(<ID>, { "delimiter".equalsIgnoreCase(getToken(1).image) }) <ID>
	  delimiter = charVal(info, "DELMITER")
	]
	[
	  (<ESCAPE> quote = charVal(info, "ESCAPE") ) { escape = true; }
	  |
	  LOOKAHEAD(<ID>, { "quote".equalsIgnoreCase(getToken(1).image) })
	  ( <ID> quote = charVal(info, "QUOTE") )
	]
	[
	  LOOKAHEAD(<ID>, { "header".equalsIgnoreCase(getToken(1).image) }) <ID>
	  [
	  	header = intVal()
	  ]
	  {
	  	if (header == null) {
	  		header = 1;
	  	}
	  }
	]
	[
	  LOOKAHEAD(<ID>, { "skip".equalsIgnoreCase(getToken(1).image) }) <ID>
	  skip = intVal()
	]
 	<RPAREN>
 	[<AS>] aliasID=id()
 	{
 		jjtThis.setFile(file);
 		jjtThis.setColumns(columns);
 		jjtThis.setDelimiter(delimiter);
 		jjtThis.setEscape(escape);
 		jjtThis.setHeader(header);
 		jjtThis.setSkip(skip);
 		try {
 		    jjtThis.setName(validateName(aliasID, false));
 		} catch (Exception ex) {
           throw new ParseException(ex.getLocalizedMessage());
        }
 		jjtThis.setQuote(quote);
 		jjtThis.setUsingRowDelimiter(useRowDelimiter);
 		return jjtThis;
 	}
}

TextColumnImpl textColumn(ParseInfo info) #TextColumnImpl :
{
	String name = null;
	ConstantImpl datatype = null;
	Integer width = null;
	boolean noTrim = false;
}
{
	name = id()
	datatype = dataType()
	[ 
	  	LOOKAHEAD(<ID>, { "width".equalsIgnoreCase(getToken(1).image) }) <ID>
	  	width = intVal() 
	  	[ LOOKAHEAD(2)
		  	<NO> nonReserved("TRIM")
		  	{
				noTrim = true;	  	
		  	}
		]
	]
	{
	    try {
	       jjtThis.setName(validateName(name, true));
	    } catch (Exception ex) {
           throw new ParseException(ex.getLocalizedMessage());
        }
        jjtThis.setType((String) datatype.getValue());
        jjtThis.setWidth(width);
        jjtThis.setNoTrim(noTrim);
        return jjtThis;
	}
}

XMLQueryImpl xmlQueryImpl(ParseInfo info) #XMLQueryImpl :
{
	String xquery = null;
	XMLNamespacesImpl xmlNamespaces = null;
	DerivedColumnImpl passing = null;
	ArrayList<DerivedColumnImpl> passingValues = new ArrayList<DerivedColumnImpl>();
	Boolean content = null;
	Boolean empty = null;
}
{
 	<XMLQUERY> <LPAREN> 
 	[ xmlNamespaces = xmlNamespaces(info) <COMMA> ]
 	xquery = stringVal()
 	[ 
 	  LOOKAHEAD(<ID>, { "passing".equalsIgnoreCase(getToken(1).image) }) <ID>
 	  passing = derivedColumn(info)
 	  {
 	  	passingValues.add(passing);
 	  	passing.setPropagateName(false);
 	  }
 	  (<COMMA>
 	    passing = derivedColumn(info)
 	    {
 	  	  passingValues.add(passing);
 	  	  passing.setPropagateName(false);
 	    }
 	  )*
 	]
/* 	[
 	  LOOKAHEAD(<ID>, { "returning".equalsIgnoreCase(getToken(1).image) }) <ID>
 	  (
 	  	LOOKAHEAD(<ID>, { "content".equalsIgnoreCase(getToken(1).image) }) <ID> { content = true; }
 	  	|
 	  	LOOKAHEAD(<ID>, { "sequence".equalsIgnoreCase(getToken(1).image) }) (<ID> { content = false; }
 	  )
 	]*/
 	[
 	  (<NULL> { empty = false; }
 	   |
 	   nonReserved("EMPTY") { empty = true; }
 	  )
 	  <ON> nonReserved("EMPTY")
 	]
 	<RPAREN>
 	{
 	    jjtThis.setXquery(xquery);
        jjtThis.setNamespaces(xmlNamespaces);
        jjtThis.setPassing(passingValues);
        jjtThis.setEmptyOnEmpty(empty);
        return jjtThis;
 	}
}

XMLTableImpl xmlTable(ParseInfo info) #XMLTableImpl :
{
	String xquery = null;
	XMLNamespacesImpl xmlNamespaces = null;
	DerivedColumnImpl passing = null;
	ArrayList<DerivedColumnImpl> passingValues = new ArrayList<DerivedColumnImpl>();
	XMLColumnImpl column = null;
	ArrayList<XMLColumnImpl> columns = new ArrayList<XMLColumnImpl>();
	String aliasID = null;
}
{
 	<XMLTABLE> <LPAREN> 
 	[ xmlNamespaces = xmlNamespaces(info) <COMMA> ]
 	xquery = stringVal()
 	[ 
 	  LOOKAHEAD(<ID>, { "passing".equalsIgnoreCase(getToken(1).image) }) <ID>
 	  passing = derivedColumn(info)
 	  {
 	  	passingValues.add(passing);
 	  	passing.setPropagateName(false);
 	  }
 	  (<COMMA>
 	    passing = derivedColumn(info)
 	    {
 	  	  passingValues.add(passing);
 	  	  passing.setPropagateName(false);
 	    }
 	  )*
 	]
 	
 	[
 	  LOOKAHEAD(<ID>, { "columns".equalsIgnoreCase(getToken(1).image) }) <ID>
 	  column = xmlColumn(info)
 	  {
 	    columns.add(column);
 	  }
 	  (<COMMA>
 	    column = xmlColumn(info)
 	    {
 	      columns.add(column); 	    
 	    }
 	  )*
 	]
 	<RPAREN>
 	[<AS>] aliasID=id()
 	{
 		jjtThis.setXquery(xquery);
        jjtThis.setNamespaces(xmlNamespaces);
        jjtThis.setPassing(passingValues);
        jjtThis.setColumns(columns);
        try {
            jjtThis.setName(validateName(aliasID, false));
        } catch (Exception ex) {
           throw new ParseException(ex.getLocalizedMessage());
        }
        return jjtThis;
 	}
}

XMLColumnImpl xmlColumn(ParseInfo info) #XMLColumnImpl :
{
	String name = null;
	ConstantImpl datatype = null;
	String path = null;
	BaseExpression defaultExpr = null;
}
{
	name = id()
	{
       jjtThis.setName(name);
    }
	((
	  <FOR> nonReserved("ORDINALITY") 
	  {
	    jjtThis.setOrdinal(true);
	    return jjtThis; 
	  }	
	) | (
      datatype = dataType()
      [
	    <DEFAULT_KEYWORD> defaultExpr = expression(info)
	  ]
      [ 
	    nonReserved("PATH") path = stringVal()
	  ]
	  {
	    jjtThis.setType((String)datatype.getValue());
        jjtThis.setPath(path);
        jjtThis.setDefaultExpression(defaultExpr);
        return jjtThis;
	  }
	))
}

int intVal() :
{
	Token t;
}
{
	t = <INTEGERVAL>
	{
		try { 
			return Integer.valueOf(t.image); 				
		} catch(NumberFormatException e1) { 
			throw new ParseException(Messages.getString(Messages.TeiidParser.Integer_parse, t.image));
		}
	}
}


/**
 * Parse a unary from clause, which is just a single group name and an optional alias.
 * @return Unary from clause containing the group
 * @throws ParseException if parsing failed
 */
SubqueryFromClauseImpl subqueryFromClauseImpl(ParseInfo info) #SubqueryFromClauseImpl :
{
    String aliasID = null;
	CommandImpl command = null;
	Token lparen = null;
	boolean table = false;
}
{	
	[
		<TABLE> { table = true; }
	]
	lparen = <LPAREN> 
	( command = queryExpression(info) |
      command = storedProcedure(info, newStoredProcedure()) )
	<RPAREN>
	[<AS>]
	aliasID = id()
	
	{
	    try {
	       jjtThis.setName(validateName(aliasID, false));
	    } catch (Exception ex) {
           throw new ParseException(ex.getLocalizedMessage());
        }
        jjtThis.setCommand(command);
        setFromClauseOptions(lparen, jjtThis);
        jjtThis.setTable(table);
        return jjtThis;
    }
}

/**
 * Parse a unary from clause, which is just a single group name and an optional alias.
 * @return Unary from clause containing the group
 * @throws ParseException if parsing failed
 */
UnaryFromClauseImpl unaryFromClauseImpl(ParseInfo info) #UnaryFromClauseImpl :
{
	GroupSymbolImpl group = null;
	Token groupID = null;
    String aliasID = null;
	UnaryFromClauseImpl clause = null;
}
{	
	(groupID=<ID> [[<AS>] aliasID=id()])
	{
    	if(aliasID != null) {
    	    try {
                group = groupSymbol(validateName(aliasID, false), normalizeId(groupID.image));
            } catch (Exception ex) {
                throw new ParseException(ex.getLocalizedMessage());
            }
        } else {
			group = groupSymbol(normalizeId(groupID.image));
        }
        jjtThis.setGroup(group);
        setFromClauseOptions(groupID, jjtThis);
		return jjtThis;
    }
}

/**
 * <p>Parse a WHERE clause.  The where clause holds a criteria.
 * @return Parsed where
 * @throws ParseException if parsing failed
 */
CriteriaImpl where(ParseInfo info) :
{
    CriteriaImpl criteria = null;
}
{
    <WHERE>
	criteria = criteria(info)
	
	{
		return criteria;
	}
}

/**
 * <p>Parse a criteria.  This will parse any criteria expression.</p>
 * @return Parsed criteria
 * @throws ParseException if parsing failed
 */
CriteriaImpl criteria(ParseInfo info) #CriteriaImpl :
{
}
{	
	jjtThis = compoundCritOr(info)

	{
		return jjtThis;
	}
}

/** 
 * <p>Parse a compound logical OR criteria.</p>
 * @return Parsed OR criteria
 * @throws ParseException if parsing failed
 */
CriteriaImpl compoundCritOr(ParseInfo info) :
{
    ArrayList logicList = new ArrayList(2);
    CriteriaImpl logicPart = null;
}
{
	logicPart=compoundCritAnd(info) 				{ logicList.add(logicPart); }
	(<OR> logicPart=compoundCritAnd(info) 			{ logicList.add(logicPart); } )*

	{
		if(logicList.size() == 1) {
			return (CriteriaImpl) logicList.get(0);
		} else {
		    CompoundCriteriaImpl cc = createASTNode(ASTNodes.COMPOUND_CRITERIA);
            cc.setOperator(CompoundCriteriaImpl.OR);
            cc.setCriteria(logicList);
         	return cc;
		}
	}
}

/**
 * <p>Parse a compound logical AND criteria.</p>
 * @return Parsed AND criteria
 * @throws ParseException if parsing failed
 */
CriteriaImpl compoundCritAnd(ParseInfo info) #CompoundCriteriaImpl :
{
    ArrayList logicList = new ArrayList(2);
    CriteriaImpl logicPart = null;
}
{
	logicPart=notCrit(info) 			{ logicList.add(logicPart); }
	(<AND> logicPart=notCrit(info) 		{ logicList.add(logicPart); } )*

	{
   		if(logicList.size() == 1) {
			return (CriteriaImpl) logicList.get(0);
		} else {
		    jjtThis.setOperator(CompoundCriteriaImpl.AND);
            jjtThis.setCriteria(logicList);
            return jjtThis;
		}
	}
}

/**
 * <p>Parse a logical NOT criteria.</p>
 * @return Parsed NOT criteria
 * @throws ParseException if parsing failed
 */
CriteriaImpl notCrit(ParseInfo info) #NotCriteriaImpl :
{
    BaseExpression ex = null;
	boolean isNot = false;
}
{
	[<NOT> {isNot=true;}] 
	ex=booleanPrimary(info)

	{
	    CriteriaImpl crit = null;
	    if (ex instanceof CriteriaImpl) {
	      crit = (CriteriaImpl)ex;
	    } else {
	      crit = expressionCriteria(ex);
	    }
  		if(isNot) {
  		    jjtThis.setCriteria(crit);
  		    return jjtThis;
		} else {
			return crit;
		}
	}
}

/**
 * <p>Parse a boolean primary.</p>
 * @return criteria
 * @throws ParseException if parsing failed
 */
BaseExpression booleanPrimary(ParseInfo info) :
{
    BaseExpression ex = null;
}
{
    (
		LOOKAHEAD(2) ex = translateCriteria(info)
		|
	    (ex = commonValueExpression(info)
	     [(
			LOOKAHEAD(2) ex=betweenCrit(info, ex) |
			LOOKAHEAD(2) ex=matchCrit(info, ex) |
			LOOKAHEAD(2) ex=regexMatchCrit(info, ex) |
			ex=setCrit(info, ex) |
			ex=isNullCrit(info, ex) |
			LOOKAHEAD(operator() (<ANY>|<SOME>|<ALL>) subquery(info)) ex=subqueryCompareCriteria(info, ex) |
			ex=compareCrit(info, ex)
	     )]
	    )
	    |
		ex=existsCriteria(info) |
		ex = hasCriteria() 
    )
	{
		return ex;
	}
}

Token operator() :
{
	Token operator = null;
}
{
	(operator=<EQ> |
    operator=<NE> |
    operator=<NE2> |
    operator=<LT> |
    operator=<LE> |
    operator=<GT> |
    operator=<GE>
    )
    {
    	return operator;
    }
}


/**
 * <p>Parse a compare criteria.</p>
 * @return Parsed compare criteria
 * @throws ParseException if parsing failed
 */
CompareCriteriaImpl compareCrit(ParseInfo info, BaseExpression expression) #CompareCriteriaImpl :
{
    BaseExpression value = null;
    Token operator = null;
}
{
	operator=operator()
	value=commonValueExpression(info)

	{
		// Set left expression
		jjtThis.setLeftExpression(expression);

		jjtThis.setOperator(Operator.getOperator(getVersion(), operator.image));
		
		// Set value
		jjtThis.setRightExpression(value);

	    return jjtThis;
	}
}

QueryCommandImpl subquery(ParseInfo info) :
{
    QueryCommandImpl subquery = null;
    StoredProcedureImpl proc = null;
}
{
	<LPAREN>
	( subquery = queryExpression(info) | 
	 (
		proc = storedProcedure(info, newStoredProcedure()) //deprecated	  
	 )
	 {
        MultipleElementSymbolImpl multipleElementSymbol = createASTNode(ASTNodes.MULTIPLE_ELEMENT_SYMBOL);

        SelectImpl select = createASTNode(ASTNodes.SELECT);
        select.setSymbols(Arrays.asList(multipleElementSymbol));

        SubqueryFromClauseImpl subqueryFromClauseImpl = createASTNode(ASTNodes.SUBQUERY_FROM_CLAUSE);
        subqueryFromClauseImpl.setName("x");
        subqueryFromClauseImpl.setCommand(proc);

        FromImpl from = createASTNode(ASTNodes.FROM);
        from.setClauses(Arrays.asList(subqueryFromClauseImpl));

        QueryImpl query = createASTNode(ASTNodes.QUERY);
        query.setSelect(select);
        query.setFrom(from);
        subquery = query;
	 }
	)
	<RPAREN>
	{
		return subquery;
	}
}

Object[] subqueryAndHint(ParseInfo info) :
{
    QueryCommandImpl subquery = null;
    Token lparen = null;
}
{
	{lparen = getToken(1);}
	subquery = subquery(info)
	{
		return new Object[] {subquery, getSubqueryHint(lparen)};
	}
}

/** 
 * <p>Parse a subquery compare criteria.</p>
 * @return Parsed subquery compare criteria
 * @throws ParseException if parsing failed
 */
SubqueryCompareCriteriaImpl subqueryCompareCriteria(ParseInfo info, BaseExpression expression) #SubqueryCompareCriteriaImpl :
{
    SubqueryCompareCriteriaImpl subqueryCrit = null;
    QueryCommandImpl subquery = null;
    Token operator = null;
    Token quantifier = null;
    
}
{
	operator=operator()
	( quantifier=<ANY> |
	  quantifier=<SOME> |
	  quantifier=<ALL>
	)
	subquery = subquery(info)

	{
	    jjtThis.setLeftExpression(expression);
	    jjtThis.setCommand(subquery);
    
		// Set operator
		jjtThis.setOperator(Operator.getOperator(getVersion(), operator.image));

		// Set predicate quantifier
		if(quantifier.image.equalsIgnoreCase("any")) { //$NON-NLS-1$
			jjtThis.setPredicateQuantifier(PredicateQuantifier.ANY);
		} else if(quantifier.image.equalsIgnoreCase("some")) { //$NON-NLS-1$
			jjtThis.setPredicateQuantifier(PredicateQuantifier.SOME);
		} else if(quantifier.image.equalsIgnoreCase("all")) { //$NON-NLS-1$
			jjtThis.setPredicateQuantifier(PredicateQuantifier.ALL);
		} 

	    return jjtThis;
   	}
}

/**
 * <p>Parse a match criteria. Also parses JDBC escape syntax for match criteria.</p>
 * @return Parsed match criteria
 * @throws ParseException if parsing failed
 */
MatchCriteriaImpl matchCrit(ParseInfo info, BaseExpression expression) #MatchCriteriaImpl :
{
    Character esc = null;
	BaseExpression value = null;
	boolean negated = false;
	boolean similar = false;
}
{
	[<NOT> {negated = true;}]
    (<LIKE>|(<SIMILAR> <TO> {similar = true;}))
	value=commonValueExpression(info)
    [   <ESCAPE> esc = charVal(info, "LIKE/SIMILAR TO ESCAPE") |
        (<LBRACE> <ESCAPE> esc = charVal(info, "LIKE/SIMILAR TO ESCAPE") <RBRACE>) 
    ]
	{
    	jjtThis.setLeftExpression(expression);
        jjtThis.setRightExpression(value);
        jjtThis.setNegated(negated);
	    if(esc != null) {
			jjtThis.setEscapeChar(esc.charValue());
		}
		jjtThis.setMode(similar?MatchMode.SIMILAR:MatchMode.LIKE);
		return jjtThis;
   	}
}

MatchCriteriaImpl regexMatchCrit(ParseInfo info, BaseExpression expression) :
{
	BaseExpression value = null;
	boolean negated = false;
}
{
	[<NOT> {negated = true;}]
    <LIKE_REGEX>
	value=commonValueExpression(info)
	{
	    MatchCriteriaImpl matchCriteria = createASTNode(ASTNodes.MATCH_CRITERIA);
        matchCriteria.setLeftExpression(expression);
        matchCriteria.setRightExpression(value);
        matchCriteria.setNegated(negated);
        matchCriteria.setMode(MatchMode.REGEX);
		return matchCriteria;
   	}
}

Character charVal(ParseInfo info, String type) :
{
	String escStr = null;
}
{
	escStr=stringVal()
	{
		if (escStr.length() != 1) {
			throw new ParseException(Messages.getString(Messages.TeiidParser.char_val));
		}
		return Character.valueOf(escStr.charAt(0));
	}
}

/**
 * <p>Parse an [NOT] BETWEEN criteria.</p>
 * @return Parsed BETWEEN criteria
 * @throws ParseException if parsing failed
 */
BetweenCriteriaImpl betweenCrit(ParseInfo info, BaseExpression expression) #BetweenCriteriaImpl :
{
	BaseExpression lowerExpression = null, upperExpression = null;
	boolean negated = false;
}
{
	[<NOT> {negated=true;}]
	<BETWEEN>
	lowerExpression = commonValueExpression(info)
	<AND>
	upperExpression = commonValueExpression(info)
	
	{
	    jjtThis.setExpression(expression);
        jjtThis.setLowerExpression(lowerExpression);
        jjtThis.setUpperExpression(upperExpression);
        jjtThis.setNegated(negated);
        return jjtThis;
	}
}

/**
 * <p>Parse an IS [NOT] NULL criteria.</p>
 * @return Parsed IS NULL criteria
 * @throws ParseException if parsing failed
 */
IsNullCriteriaImpl isNullCrit(ParseInfo info, BaseExpression expression) #IsNullCriteriaImpl :
{
	boolean negated = false;
}
{
	<IS>
	[<NOT> {negated = true;}]
	<NULL>

	{
	   jjtThis.setExpression(expression);
       jjtThis.setNegated(negated);
       return jjtThis;
	}
}

/** 
 * <p>Parse a set criteria.</p>
 * @return Parsed set criteria
 * @throws ParseException if parsing failed
 */
AbstractSetCriteria setCrit(ParseInfo info, BaseExpression expression) :
{
    AbstractSetCriteria criteria = null;
	BaseExpression value = null;
	List setList = new ArrayList();
	Object[] command = null;
	boolean negated = false;
}
{
	[<NOT> {negated = true;}]
	<IN>
	(
		LOOKAHEAD(subquery(info)) (command = subqueryAndHint(info)) |
		(
			<LPAREN>
			value = commonValueExpression(info)
			{
				setList.add(value);
			}
			( <COMMA>
				value = commonValueExpression(info)
				{
					setList.add(value);
				}
			)*
			<RPAREN>
		)
	)
	{
	    if (command != null) {
			SubquerySetCriteriaImpl ssc = subquerySetCriteriaImpl(expression, (QueryCommandImpl)command[0]);
			ssc.setSubqueryHint((SubqueryHint)command[1]);
			criteria = ssc;
		} else {
		    criteria = setCriteria(expression, setList);
		}
	    criteria.setNegated(negated);
	    return criteria;
   	}
}

SubquerySetCriteriaImpl subquerySetCriteriaImpl(BaseExpression expression, QueryCommandImpl command) #SubquerySetCriteriaImpl :
{
}
{
    {
        jjtThis.setExpression(expression);
        jjtThis.setCommand(command);
        return jjtThis;
    }
}

SetCriteriaImpl setCriteria(BaseExpression expression, List<BaseExpression> values) #SetCriteriaImpl :
{
}
{
    {
        jjtThis.setExpression(expression);
        jjtThis.setValues(values);
        return jjtThis;
    }
}

/** 
 * <p>Parse an exists criteria.</p>
 * @return Parsed exists criteria
 * @throws ParseException if parsing failed
 */
ExistsCriteriaImpl existsCriteria(ParseInfo info) #ExistsCriteriaImpl :
{
    Object[] subquery = null;
}
{
	<EXISTS>
	subquery = subqueryAndHint(info)

	{
	    jjtThis.setCommand((QueryCommandImpl) subquery[0]);
        jjtThis.setSubqueryHint((SubqueryHint) subquery[1]);
        return jjtThis;
   	}
}

/**
 * <p>Parse a GROUP BY clause.  </p>
 * @return Parsed group by
 * @throws ParseException if parsing failed
 */
GroupByImpl groupBy(ParseInfo info) #GroupByImpl :
{
	List<BaseExpression> expressions = null;
}
{
	<GROUP> <BY>
    expressions = expressionList(info)	
	{
	    jjtThis.setSymbols(expressions);
        return jjtThis;
	}
}

/**
 * <p>Parse a HAVING clause.  </p>
 * @return Parsed having
 * @throws ParseException if parsing failed
 */
CriteriaImpl having(ParseInfo info) :
{
    CriteriaImpl criteria = null;
}
{
    <HAVING>
	criteria = criteria(info)
	{
		return criteria;
	}
}

	
/** 
 * <p>Parse an ORDER BY clause.</p>
 * @return Parsed ORDER BY
 * @throws ParseException if parsing failed
 */
OrderByImpl orderby(ParseInfo info) #OrderByImpl :
{
    OrderByItemImpl item = null;
}
{
	<ORDER> <BY>
	item = sortSpecification(info)
	{
    	jjtThis.getOrderByItems().add(item);
	}
	(<COMMA>
		item = sortSpecification(info)
		{
    		jjtThis.getOrderByItems().add(item);
		}
	)*
	{
	    return jjtThis;
	}
}

OrderByItemImpl sortSpecification(ParseInfo info) #OrderByItemImpl :
{
    SingleElementSymbol ex = null;
    boolean ascending = true;
    String nullOrdering = null;
}
{
	ex=sortKey(info) 
	[<ASC> | <DESC> {ascending=false;}]
	[nonReserved("NULLS") nullOrdering = nonReserved("FIRST", "LAST")] 
	{
	    jjtThis.setSymbol(ex);
        jjtThis.setAscending(ascending);
    	if (nullOrdering != null) {
    		jjtThis.setNullOrdering(NullOrdering.valueOf(nullOrdering.toUpperCase()));
    	}
    	return jjtThis;
	}
}

SingleElementSymbol sortKey(ParseInfo info) :
{
    BaseExpression ex = null;
}
{
    ex=expression(info)
    {
        //legacy support check for positional constants
        if (ex instanceof ConstantImpl) {
        	boolean valid = false;
            ConstantImpl c = (ConstantImpl)ex;
            if (c.getValue() instanceof Integer) {
                Integer val = (Integer)c.getValue();
                valid = val.intValue() > 0;
            }      
            if (!valid) {
            	throw new ParseException(Messages.getString(Messages.TeiidParser.non_position_constant, ex));
            }
        } 
        if(ex instanceof ElementSymbolImpl) {
            return (ElementSymbolImpl)ex;
        } 
        String exprName = generateFunctionName(info, null);
        ExpressionSymbolImpl es = expressionSymbol();
        es.setName(exprName);
        es.setExpression(ex);
        return es;
    }
}

ExpressionSymbolImpl expressionSymbol() #ExpressionSymbolImpl :
{
}
{
    {
        return jjtThis;
    }
}

BaseExpression intParam(ParseInfo info) :
{
   Integer val = null;
}
{
   (val = intVal() | <QMARK>)
   {
     if (val == null) {
       return reference(info.incrementReferenceCount());
     } 
     return constant(val, DefaultDataTypeManager.DefaultDataTypes.INTEGER);
   }
}

/** 
 * <p>Parse an LIMIT clause.</p>
 * @return Parsed LIMIT
 * @throws ParseException if parsing failed
 */
LimitImpl limit(ParseInfo info) #LimitImpl :
{
	BaseExpression limit = null;
	BaseExpression offset = null;
	Token t = null;
}
{
    {t = getToken(1);}
    ((<LIMIT> offset = intParam(info)
	[<COMMA> limit = intParam(info)])
	{
	  if (limit == null) {
	    limit = offset;
	    offset = null;
	  }
	}
	|
	(<OFFSET> offset = intParam(info) (<ROW>|<ROWS>) 
    [limit = fetchLimitImpl(info)])
    |
    (limit = fetchLimitImpl(info)))
	{
	    jjtThis.setOffset(offset);
        jjtThis.setRowLimit(limit);
        jjtThis.setStrict(!isNonStrictHint(t));
        return jjtThis;
	}
}

BaseExpression fetchLimitImpl(ParseInfo info) :
{
    BaseExpression limit = null;
}
{
    <FETCH> nonReserved("FIRST", "NEXT") [limit = intParam(info)] (<ROW>|<ROWS>) <ONLY>
    {
      if (limit == null) {
        return constant(1, DefaultDataTypeManager.DefaultDataTypes.INTEGER); 
      }
      return limit;
    }
}

/** 
 * <p>Parse an OPTION clause.</p>
 * @return Parsed OPTION clause
 * @throws ParseException if parsing failed
 */
OptionImpl option(ParseInfo info) #OptionImpl :
{
	String id = null;
	Token nocache = null;
}
{
	<OPTION>
	(
		<MAKEDEP>		
		id=id()
		{
            jjtThis.addDependentGroup(id);
		}
		(<COMMA>
			id=id()
			{
                jjtThis.addDependentGroup(id);
	        }
		)* |
		<MAKENOTDEP>		
		id=id()
		{
            jjtThis.addNotDependentGroup(id);
		}
		(<COMMA>
			id=id()
			{
                jjtThis.addNotDependentGroup(id);
	        }
		)* |
		
		nocache	= <NOCACHE>		
		[id=id()
		{
            jjtThis.addNoCacheGroup(id);
		}
		(<COMMA>
			id=id()
			{
                jjtThis.addNoCacheGroup(id);
	        }
		)*]
	)*

	{
		jjtThis.setNoCache( (nocache != null) );
		return jjtThis;
	}
}

/**
 * <p>Parse an expression - made up of literals and functions.</p>
 * @return BaseExpression
 * @throws ParseException if parsing failed
 */
BaseExpression expression(ParseInfo info) :
{
	BaseExpression expression = null;
}
{
    expression = criteria(info)
	{
		if (expression instanceof ExpressionCriteriaImpl) {
			return ((ExpressionCriteriaImpl)expression).getExpression();
		}
		return expression;
	}
}

BaseExpression commonValueExpression(ParseInfo info) :
{
	BaseExpression leftExpression = null;
	BaseExpression rightExpression = null;
}
{
	(	leftExpression=plusExpression(info)
		(
			<CONCAT_OP>
			rightExpression=plusExpression(info)
			{
			    FunctionImpl function = createASTNode(ASTNodes.FUNCTION);
                function.setName("||"); //$NON-NLS-1$
                function.setArgs(new BaseExpression[] {leftExpression, rightExpression});
                leftExpression = function;
				rightExpression = null;				
			}
		)*
	)

	{
		return leftExpression;
	}
}

/**
 * <p>Parse an expression - made up of literals and functions.</p>
 * @return BaseExpression
 * @throws ParseException if parsing failed
 */
BaseExpression plusExpression(ParseInfo info) :
{
	BaseExpression leftExpression = null;
	BaseExpression rightExpression = null;
	String operator = null;
}
{
	(	leftExpression=timesExpression(info)
		(
			operator=plusOperator()
			rightExpression=timesExpression(info)
			{
			    FunctionImpl function = createASTNode(ASTNodes.FUNCTION);
                function.setName(operator);
                function.setArgs(new BaseExpression[] { leftExpression, rightExpression });
                leftExpression = function;
				rightExpression = null;
				operator = null;
			}
		)*
	)

	{
		return leftExpression;
	}
}

/**
 * <p>Parse the add/subtract operators.</p>
 * @return "+" or "-"
 * @throws ParseException if parsing failed
 */
String plusOperator() :
{
	Token operator = null;
}
{
	(	operator = <PLUS> |
		operator = <MINUS>
	)

	{
		return operator.image;
	}
}

/**
 * <p>Parse an expression - made up of literals and functions.</p>
 * @return BaseExpression
 * @throws ParseException if parsing failed
 */
BaseExpression timesExpression(ParseInfo info) :
{
	BaseExpression leftExpression = null;
	BaseExpression rightExpression = null;
	String operator = null;
}
{
	(	leftExpression=valueExpressionPrimary(info)
		(
			operator=timesOperator()
			rightExpression=valueExpressionPrimary(info) 
			{
			    FunctionImpl function = createASTNode(ASTNodes.FUNCTION);
                function.setName(operator);
                function.setArgs(new BaseExpression[] {leftExpression, rightExpression});
                leftExpression = function;
				rightExpression = null;
				operator = null;
			}
		)*
	)

	{
		return leftExpression;
	}
}

/**
 * <p>Parse the multiply/divide operator.</p>
 * @return "*" or "/"
 * @throws ParseException if parsing failed
 */
String timesOperator() :
{
	Token operator = null;
}
{
	(	operator = <STAR> |
		operator = <SLASH>
	)

	{
		return operator.image;
	}
}

/**
 * <p>Parse a basic expression.</p>
 * @return BaseExpression
 * @throws ParseException if parsing failed
 */
BaseExpression valueExpressionPrimary(ParseInfo info) :
{
	Token refToken = null;
	BaseExpression expression = null;
	Token symbol = null;
	ConstantImpl literal = null;	
	QueryCommandImpl subquery = null;
	Integer arrayIndex = null;
}
{
        (
		// ReferenceImpl
		refToken=<QMARK>
		|
		refToken=<POS_REF>
		|
		// Literal
		literal=literal()
		|
		// Escaped function
		(	<LBRACE> nonReserved("FN")
			expression=function(info)
			<RBRACE>
		)
		|
		LOOKAHEAD(<ID> <LPAREN>, {matchesAny(getToken(1).image, "textagg") != null}) 
		(expression=textAgg(info) [expression = windowSpecification(expression, info)])				
		|		
		// Aggregate function
		LOOKAHEAD(<ID> <LPAREN>, {matchesAny(getToken(1).image, "count", "min", "max", "sum", "avg", "every", "STDDEV_POP", "STDDEV_SAMP", "VAR_SAMP", "VAR_POP") != null}) 
		(expression=aggregateSymbol(info) [expression = windowSpecification(expression, info)])
		|
		LOOKAHEAD(<ANY>|<SOME>) (expression=aggregateSymbol(info) [expression = windowSpecification(expression, info)])
		|
		expression=orderedAgg(info) [expression = windowSpecification(expression, info)]
		|
		LOOKAHEAD(<ID> <LPAREN>, {matchesAny(getToken(1).image, "rank", "dense_rank", "row_number") != null}) 
		(expression=aggregateSymbol(info) expression = windowSpecification(expression, info))
		|
		// Function
		LOOKAHEAD(2) (expression=function(info))
		|
		// ElementSymbolImpl
		(symbol=<ID> 
			{
				String symbolImage = symbol.image;
				if(isStringLiteral(symbolImage, info)) {
				    literal = constant(normalizeStringLiteral(symbolImage));
				    symbol = null;
				}  
			}
			(<LSBRACE> arrayIndex = intVal() <RSBRACE>)?
		)
		|
		LOOKAHEAD(subquery(info)) subquery = subquery(info)
		|
		( <LPAREN> 
 			expression = expression(info)
		  <RPAREN>
		  (<LSBRACE> arrayIndex = intVal() <RSBRACE>)?
		)
		|
		// Searched CASE expressions
		LOOKAHEAD(2) expression = searchedCaseExpression(info)
		|
		// Non-searched CASE expressions
		expression = caseExpression(info)
	)						
		
	{
		if(refToken != null) {
		    if (refToken.image.charAt(0) == '$') {
				return reference(Integer.parseInt(refToken.image.substring(1)) -1);
		    }
			expression = reference(info.incrementReferenceCount());
		} else if(symbol != null) {
			expression = elementSymbol(normalizeId(symbol.image));
		} else if(literal != null) {
			expression = literal;		// may be null literal
		} else if (subquery != null){
			expression = scalarSubquery(subquery);
		}
		if (arrayIndex != null) {
		    FunctionImpl function = createASTNode(ASTNodes.FUNCTION);
            function.setName("array_get"); //$NON-NLS-1$
            function.setArgs(new BaseExpression[] {expression, constant(arrayIndex)});
            expression = function;		
		}
		return expression;
	}
}

ReferenceImpl reference(int referenceIndex) #ReferenceImpl :
{
}
{
    {
        jjtThis.setIndex(referenceIndex);
        jjtThis.setPositional(true);
        return jjtThis;
    }
}

BaseExpression windowSpecification(BaseExpression agg, ParseInfo info) :
{
	List<BaseExpression> partitionList = null;
	OrderByImpl orderBy = null;
}
{
	<OVER> 
    <LPAREN> 
    [<PARTITION> <BY> partitionList = expressionList(info)]
    [orderBy = orderby(info)]
    <RPAREN>
    {
        String aggName = "win_" + ((BaseAggregateSymbol)agg).getName();
		String name = generateFunctionName(info, aggName);
        
    	BaseWindowFunction result = windowFunction();
    	result.setName(aggName);
    	WindowSpecificationImpl ws = newWindowSpecificationImpl();
    	result.setFunction((BaseAggregateSymbol)agg);
    	ws.setPartition(partitionList);
    	ws.setOrderBy(orderBy);
    	result.setWindowSpecification(ws);
    	return result;
    }
}

/**
 * Parse a non-searched CASE expression.
 * @return CaseExpression
 * @throws ParseException if parsing failed
 */
CaseExpressionImpl caseExpression(ParseInfo info) #CaseExpressionImpl :
{
	BaseExpression expression = null, whenExpression = null, thenExpression = null, elseExpression = null;
	ArrayList whenExpressions = new ArrayList(2);
	ArrayList thenExpressions = new ArrayList(2);
}
{
	<CASE>
	expression = expression(info)
	(
		<WHEN>
		whenExpression = expression(info)
		<THEN>
		thenExpression = expression(info)
		{
			whenExpressions.add(whenExpression);
			thenExpressions.add(thenExpression);
		}
	)+
	[<ELSE> elseExpression = expression(info)]
	<END>
	{
		jjtThis.setExpression(expression);
        jjtThis.setWhen(whenExpressions, thenExpressions);
        jjtThis.setElseExpression(elseExpression);
        return jjtThis;
	}
}

/**
 * Parse a searched CASE expression.
 * @return SearchedCaseExpression
 * @throws ParseException if parsing failed
 */
SearchedCaseExpressionImpl searchedCaseExpression(ParseInfo info) #SearchedCaseExpressionImpl :
{
	BaseExpression thenExpression = null, elseExpression = null;
	CriteriaImpl whenCriteria = null;
	List<CriteriaImpl> whenCriteriaList = new ArrayList<CriteriaImpl>(2);
	List<BaseExpression> thenExpressions = new ArrayList<BaseExpression>(2);
}
{
	<CASE>
	(
		<WHEN>
		whenCriteria = criteria(info)
		<THEN>
		thenExpression = expression(info)
		{
			whenCriteriaList.add(whenCriteria);
			thenExpressions.add(thenExpression);
		}
	)+
	
	[<ELSE> elseExpression = expression(info)]
	<END>
	{
		jjtThis.setWhen(whenCriteriaList, thenExpressions);
        jjtThis.setElseExpression(elseExpression);
        return jjtThis;
	}
}

/**
 * <p>Parse a function. </p>
 * @return Parsed function
 * @throws ParseException if parsing failed
 */
BaseExpression function(ParseInfo info) #FunctionImpl :
{
	String funcName = null;
    
	BaseExpression expression = null;
	ArrayList args = new ArrayList(2);
	ArrayList otherArgs = null;
	Token funcToken = null;
}
{
	((	funcToken = <CONVERT>
		<LPAREN>
		expression = expression(info)
		{
			args.add(expression);
		}
		<COMMA>
		expression = dataType()	
		{
			args.add(expression);
		}
		<RPAREN> 
	)
	|
	(			
		funcToken = <CAST>
		<LPAREN>
		expression = expression(info)
		{
			args.add(expression);
		} 
		<AS>
		expression = dataType()
		{
			args.add(expression);
		}
		<RPAREN>				
	)
	|
	LOOKAHEAD(2, {getToken(1).image.equalsIgnoreCase("SUBSTRING")}) (
	   funcName = nonReserved("SUBSTRING")
	   <LPAREN>
	   expression = expression(info)
	   {
	      args.add(expression);
	   }
	   ((<FROM> expression = expression(info)
	   {
	      args.add(expression);
	   }
  	   [<FOR> expression = expression(info)
	    {
	      args.add(expression);
	    }
	   ])|(<COMMA> otherArgs = expressionList(info)) {args.addAll(otherArgs);})
	   <RPAREN>
	)
	|
	LOOKAHEAD(2, {getToken(1).image.equalsIgnoreCase("EXTRACT")}) (
	   nonReserved("EXTRACT")
	   <LPAREN>
	   (funcToken = <YEAR> | 
	    funcToken = <MONTH> |
	    funcToken = <DAY> |
	    funcToken = <HOUR> |
	    funcToken = <MINUTE> |
	    funcToken = <SECOND>)
	   <FROM> expression = expression(info)
	   {
	   	  if (funcToken.image.equalsIgnoreCase("DAY")) {
	         funcName = "DAYOFMONTH";
	      }  	      
	      args.add(expression);
	   }
	   <RPAREN>
	)
	|
	LOOKAHEAD(2, {getToken(1).image.equalsIgnoreCase("TRIM")}) (
	   funcName= nonReserved("TRIM")
	   <LPAREN>
	   { funcToken = null; expression = null;}
	   [
	    LOOKAHEAD(2) (((funcToken = <LEADING>|
	      funcToken = <TRAILING>|
	      funcToken = <BOTH>)
	    [expression = expression(info)])
	    |
	    expression = expression(info))
		<FROM>
	   ]
  	   {
	      if (funcToken == null) {
	      	  args.add(constant("BOTH"));
	      } else {
	          args.add(constant(funcToken.image));
	      }
	      if (expression == null) {
	          args.add(constant(" "));
	      } else {
	          if (expression instanceof ConstantImpl) {
	              Object value = ((ConstantImpl)expression).getValue();
	              if (value instanceof String && ((String)value).length() != 1) {
				      throw new ParseException(Messages.getString(Messages.TeiidParser.char_val));
	              }
	          }
	          args.add(expression);
	      }
	   }
	   expression = expression(info)
	   {
	      args.add(expression);
	   }
	   <RPAREN>
	)
	|
	LOOKAHEAD(<ID>, {matchesAny(getToken(1).image, "to_chars", "to_bytes") != null}) (	
		funcName = nonReserved("TO_CHARS", "TO_BYTES")
		<LPAREN>
		expression = expression(info) 
		{		
			args.add(expression);
		}
		<COMMA>
		expression = stringConstant()
		{
			args.add(expression);
		} 
		<RPAREN>				
	)
	|
	LOOKAHEAD(<ID>, {matchesAny(getToken(1).image, "timestampadd", "timestampdiff") != null}) (	
		funcName = nonReserved("TIMESTAMPADD", "TIMESTAMPDIFF")
		<LPAREN>
		expression = intervalType() 
		{		
			args.add(expression);
		}
		<COMMA>
		expression = expression(info)
		{
			args.add(expression);
		} 
		<COMMA>
		expression = expression(info)
		{
			args.add(expression);
		} 
		<RPAREN>				
	)
	|
	LOOKAHEAD(<ID>, {getToken(1).image.equalsIgnoreCase("querystring")}) expression = queryString(info)
	  {
		return expression;
	  }		
	|
	(
		(funcToken = <LEFT> | funcToken = <RIGHT> | funcToken = <CHAR> | funcToken = <USER> 
		                    | funcToken = <YEAR> | funcToken = <MONTH> | funcToken = <HOUR>
		                    | funcToken = <MINUTE> | funcToken = <SECOND> | funcToken = <XMLCONCAT>
		                    | funcToken = <XMLCOMMENT>)
        <LPAREN>
		[args = expressionList(info)]
		<RPAREN>
	)		
	|
	LOOKAHEAD(<TRANSLATE>|<INSERT> <LPAREN>) (
		(funcToken = <TRANSLATE> | funcToken = <INSERT>)
		<LPAREN>
		[args = expressionList(info)]
		<RPAREN>
	)  
	| expression = xmlParse(info)
	  {
	  	return expression;
	  }
	| expression = xmlElement(info)
	  {
	  	return expression;
	  }
	| ( funcToken = <XMLPI>
		<LPAREN>
		(
		 LOOKAHEAD(<ID>, { "name".equalsIgnoreCase(getToken(1).image) }) <ID> expression = idExpression()
		 |
		 expression = idExpression()
		)
		{
			args.add(expression);	
		}
		[
			<COMMA> expression = expression(info)
			{
				args.add(expression);	
			}	
		]
		<RPAREN>
	)
	|	expression = xmlForest(info)
		{
			return expression;
		}
	|	expression = xmlSerialize(info)
		{
			return expression;
		}
	|	expression = xmlQueryImpl(info)
		{
			return expression;
		}
	|   
	(	funcName = id()
		<LPAREN>
		[ args = expressionList(info) ]
		<RPAREN>
	))		
	{
		if(funcName == null) { 
			funcName = funcToken.image;
		}
		jjtThis.setName(funcName);
        jjtThis.setArgs((BaseExpression[])args.toArray(new BaseExpression[args.size()]));
        return jjtThis;
	}
}

ConstantImpl stringConstant() :
{
	String val = null;
}
{
	val = stringVal()
	{
		return constant(val);
	}
}

XMLParseImpl xmlParse(ParseInfo info) #XMLParseImpl :
{
	BaseExpression expr = null;
	String doc = null;
	boolean wellformed = false;
}
{
	<XMLPARSE><LPAREN>
	doc = nonReserved("DOCUMENT", "CONTENT")
	expr = expression(info)
	[nonReserved("WELLFORMED")
	 {
	   wellformed = true;
	 }
	]
	<RPAREN>
	{
		jjtThis.setDocument("document".equalsIgnoreCase(doc));
		jjtThis.setExpression(expr);
		jjtThis.setWellFormed(wellformed);
		return jjtThis;
	}
}

QueryStringImpl queryString(ParseInfo info) #QueryStringImpl :
{
	BaseExpression path = null;
	DerivedColumnImpl arg = null;
	ArrayList<DerivedColumnImpl> args = new ArrayList<DerivedColumnImpl>(2);
}
{
 	nonReserved("QUERYSTRING") <LPAREN>
 	path = expression(info)
	(<COMMA> arg=derivedColumn(info)
	 {
		args.add(arg);
		arg = null;
	 }
	)*
	<RPAREN>  		
	{
		jjtThis.setPath(path);
        jjtThis.setArgs(args);
        return jjtThis;
	}
}

XMLElementImpl xmlElement(ParseInfo info) #XMLElementImpl :
{
	String name = null;
	ArrayList content = new ArrayList(2);
	XMLNamespacesImpl xmlNamespaces = null;
	XMLAttributesImpl xmlAttributes = null;
	BaseExpression expression = null;
}
{
	<XMLELEMENT> <LPAREN>
	(
	 LOOKAHEAD(<ID>, { "name".equalsIgnoreCase(getToken(1).image) }) <ID> name = id()
	 |
	 name = id()
	)
	[
		LOOKAHEAD(2) <COMMA> xmlNamespaces = xmlNamespaces(info)
	]
	[
		LOOKAHEAD(2) <COMMA> xmlAttributes = xmlAttributes(info)
	]
	(<COMMA> expression=expression(info)
	{
		content.add(expression);
	}
	)*
	<RPAREN>
	{
		jjtThis.setName(name);
        jjtThis.setContent(content);
        jjtThis.setNamespaces(xmlNamespaces);
        jjtThis.setAttributes(xmlAttributes);
        return jjtThis;
	}
}	

XMLAttributesImpl xmlAttributes(ParseInfo info) #XMLAttributesImpl :
{
	DerivedColumnImpl expression = null;
	ArrayList<DerivedColumnImpl> args = new ArrayList<DerivedColumnImpl>(2);
}
{
 	<XMLATTRIBUTES> <LPAREN>
	expression = derivedColumn(info)
	{
		args.add(expression);
	}
	(<COMMA> expression=derivedColumn(info)
	 {
		args.add(expression);
	 }
	)*
	<RPAREN>  		
	{
		jjtThis.setArgs(args);
        return jjtThis;
	}
}

XMLForestImpl xmlForest(ParseInfo info) #XMLForestImpl :
{
	DerivedColumnImpl expression = null;
	XMLNamespacesImpl xmlNamespaces = null;
	ArrayList<DerivedColumnImpl> args = new ArrayList<DerivedColumnImpl>(2);
}
{
 	<XMLFOREST> <LPAREN>
	[
		xmlNamespaces = xmlNamespaces(info) <COMMA>
	]
	expression = derivedColumn(info)
	{
		args.add(expression);
	}
	(<COMMA> expression=derivedColumn(info)
	 {
		args.add(expression);
	 }
	)*
	<RPAREN>  		
	{
		jjtThis.setArguments(args);
        jjtThis.setNamespaces(xmlNamespaces);
        return jjtThis;
	}
}		
		
XMLNamespacesImpl xmlNamespaces(ParseInfo info) #XMLNamespacesImpl :
{
	ArrayList namespaces = new ArrayList(2);
	NamespaceItem item = null;
}
{
 	<XMLNAMESPACES> <LPAREN>
	item = namespaceItem(info)
	{
		namespaces.add(item);
	}
	(<COMMA> item = namespaceItem(info)
	 {
		 namespaces.add(item);
	 }
	)*
	<RPAREN>  		
	{
		jjtThis.setNamespaces(namespaces);
        return jjtThis;
	}
}

NamespaceItem namespaceItem(ParseInfo info) :
{
	String uri = null;
	String prefix = null;
}
{
	(
		uri = stringVal() <AS> prefix = id()
		{
			return new NamespaceItem(uri, prefix);
		}
	) | (
		<NO> <DEFAULT_KEYWORD>
		{
			return new NamespaceItem();
		}
	) | (
		<DEFAULT_KEYWORD> uri = stringVal()
		{
			return new NamespaceItem(uri);
		}
	)
}

ConstantImpl idExpression() :
{
	String id = null;
}
{
	id = id()
	{
		return constant(id);
	}
}

String dataTypeString() : 
{
	Token typeToken = null;
}
{
	(
		typeToken = <STRING> |
		typeToken = <VARCHAR> | 
		typeToken = <BOOLEAN> | 
		typeToken = <BYTE> | 
		typeToken = <TINYINT> |
		typeToken = <SHORT> | 
		typeToken = <SMALLINT> |
		typeToken = <CHAR> | 
		typeToken = <INTEGER> | 
		typeToken = <LONG> | 
		typeToken = <BIGINT> |
		typeToken = <BIGINTEGER> | 
		typeToken = <FLOAT> |
		typeToken = <REAL> | 
		typeToken = <DOUBLE> | 
		typeToken = <BIGDECIMAL> |
		typeToken = <DECIMAL> | 
		typeToken = <DATE> | 
		typeToken = <TIME> |
		typeToken = <TIMESTAMP> |
		typeToken = <OBJECT> |
		typeToken = <BLOB> |
		typeToken = <CLOB> |
		typeToken = <XML>
		
	)
	
	{
		return typeToken.image;
	}
}


ConstantImpl dataType() :
{
	String type = null;
}
{
	type = dataTypeString()	
	{
		return constant(type);
	}
}

/**
 * Parse an interval type name - used only in TIMESTAMPADD and TIMESTAMPDIFF functions.
 * @return Interval type parsed into a constant string object
 * @throws ParseException if parsing failed
 */
ConstantImpl intervalType() :
{
	String type = null;
}
{
	(
		type = nonReserved("SQL_TSI_FRAC_SECOND", "SQL_TSI_SECOND", "SQL_TSI_MINUTE", "SQL_TSI_HOUR", "SQL_TSI_DAY", "SQL_TSI_WEEK", "SQL_TSI_MONTH", "SQL_TSI_QUARTER", "SQL_TSI_YEAR")
	)
	{
		return constant(type);
	}
}
/**
 * <p>Parse a literal - strings must be wrapped in either '' or "".
 * JDBC escape syntax is parsed for Date, Time and Timestamp value.</p>
 * @return Parsed literal
 * @throws ParseException if parsing failed
 */
ConstantImpl literal() :
{
    Token t = null;
    String strVal = null;
    DefaultDataTypeManager.DefaultDataTypes escapeType = null;
    ConstantImpl constant = null;
}
{
	(	
		strVal=stringVal()	{ 
			constant = constant(strVal, DefaultDataTypeManager.DefaultDataTypes.STRING);
		} |
		
		t=<INTEGERVAL> 	{ 
			try { 
				// First try as integer - this should nearly always work
				constant = constant(Integer.valueOf(t.image), DefaultDataTypeManager.DefaultDataTypes.INTEGER); 				
			} catch(NumberFormatException e1) { 
				try { 
					// Second try as a long
					constant = constant(Long.valueOf(t.image), DefaultDataTypeManager.DefaultDataTypes.LONG);
				} catch(NumberFormatException e2) {
					try {
						// Third try as a biginteger
						constant = constant(new BigInteger(t.image), DefaultDataTypeManager.DefaultDataTypes.BIG_INTEGER);
					} catch(NumberFormatException e3) {
						Object[] params = new Object[] { t.image };
						throw new ParseException(Messages.getString(Messages.TeiidParser.Integer_parse, params));
					}
				}
			}			
		}	|
		
		t=<FLOATVAL>	{ 
			try { 
				constant = constant(Double.valueOf(t.image), DefaultDataTypeManager.DefaultDataTypes.DOUBLE); 
			} catch(NumberFormatException e) {
				Object[] params = new Object[] { t.image };
				throw new ParseException(Messages.getString(Messages.TeiidParser.Float_parse, params));
			}
		}   |
		
		t=<FALSE>    { constant = constant(Boolean.FALSE, DefaultDataTypeManager.DefaultDataTypes.BOOLEAN); } |
		t=<TRUE>     { constant = constant(Boolean.TRUE, DefaultDataTypeManager.DefaultDataTypes.BOOLEAN); }  |
        t=<UNKNOWN>  { constant = constant(null, DefaultDataTypeManager.DefaultDataTypes.BOOLEAN); }       |
        t=<NULL>     { constant = constant(null); }          |
        
        ( (<BOOLEANTYPE>   { escapeType=DefaultDataTypeManager.DefaultDataTypes.BOOLEAN; } |
          <TIMESTAMPTYPE> { escapeType=DefaultDataTypeManager.DefaultDataTypes.TIMESTAMP; } | 
          <DATETYPE>      { escapeType=DefaultDataTypeManager.DefaultDataTypes.DATE; } |
          <TIMETYPE>      { escapeType=DefaultDataTypeManager.DefaultDataTypes.TIME; }) strVal=stringVal() { 
	        	try {
	        		constant = constant(getDataTypeService().transformValue(strVal, escapeType), escapeType);
	        	} catch (Exception e) {
	        		throw new ParseException(e.getMessage());
	        	}
	        } <RBRACE> ) 

	)
	{
		return constant;
	}
}

AssignmentStatementImpl assignmentStatement(ElementSymbolImpl elementSymbol, BaseLanguageObject value) #AssignmentStatementImpl :
{
}
{
    {
        jjtThis.setVariable(elementSymbol);

        if (value instanceof BaseExpression)
            jjtThis.setExpression((BaseExpression) value);
        else if (value instanceof QueryCommandImpl)
            jjtThis.setExpression(scalarSubquery((QueryCommandImpl) value));
        else
            jjtThis.setCommand((CommandImpl) value);

        return jjtThis;
    }
}

ScalarSubqueryImpl scalarSubquery(QueryCommandImpl queryCommand) #ScalarSubqueryImpl :
{
}
{
    {
        jjtThis.setCommand(queryCommand);
        return jjtThis;
    }
}

GroupSymbolImpl groupSymbol(String... args) #GroupSymbolImpl :
{
}
{ 
    {
        /*
         * Expectation is that group symbol args should be
         * name then definition (or alias).
         */
        jjtThis.setName(args[0]);
        if (args.length == 2)
            jjtThis.setDefinition(args[1]);

        return jjtThis;
    }
}

ConstantImpl constant(Object... args) #ConstantImpl :
{
}
{ 
    {
        if (args == null)
            return jjtThis;

        /*
         * Expectation is that constant args should be
         * value of type Object and type of type Class.
         */
        for (Object arg : args) {
            if (arg instanceof Class) {
                jjtThis.setType((Class) arg);            } else if (arg instanceof DefaultDataTypeManager.DefaultDataTypes) {
                DefaultDataTypeManager.DefaultDataTypes dataType = (DefaultDataTypeManager.DefaultDataTypes) arg;                jjtThis.setType(dataType.getTypeClass());
            } else {                jjtThis.setValue(arg);
            }
        }
        return jjtThis;
    }
}

ElementSymbolImpl elementSymbol(String name) #ElementSymbolImpl :
{
}
{ 
    {
        jjtThis.setName(name);
        return jjtThis;
    }
}

BlockImpl block() #BlockImpl :
{
}
{
    {
        return jjtThis;
    }
}

BlockImpl asBlock(StatementImpl stmt) :
{
  BlockImpl b = null;
}
{
    {
        if (stmt == null)
            return null;

        if (stmt instanceof BlockImpl)
            return (BlockImpl) stmt;

        b = block();
        b.addStatement(stmt);
        return b;
    }
}

ExpressionCriteriaImpl expressionCriteria(BaseExpression expression) #ExpressionCriteriaImpl :
{
}
{
    {
        jjtThis.setExpression(expression);
        return jjtThis;
    }
}

AliasSymbolImpl aliasSymbol(String alias, BaseExpression expression) #AliasSymbolImpl :
{
}
{
    {
        jjtThis.setName(alias);
        jjtThis.setSymbol(expression);
        return jjtThis;
    }
}

BaseAggregateSymbol newBaseAggregateSymbol(String name, String aggregateFunction, boolean isDistinct, BaseExpression expression) #BaseAggregateSymbol :
{
}
{
    {
        jjtThis.setName(name);
        jjtThis.setAggregateFunction(aggregateFunction);
        jjtThis.setDistinct(isDistinct);
        jjtThis.setExpression(expression);
        return jjtThis;
    }
}

BaseWindowFunction windowFunction() #BaseWindowFunction :
{
}
{
    {
        return jjtThis;
    }
}

WindowSpecificationImpl newWindowSpecificationImpl() #WindowSpecificationImpl :
{
}
{
    {
        return jjtThis;
    }
}


TextLineImpl textLine() #TextLineImpl :
{
}
{
    {
        return jjtThis;
    }
}

AlterTriggerImpl alterTrigger() #AlterTriggerImpl :
{
}
{
    {
        return jjtThis;
    }
}

AlterProcedureImpl alterProcedure() #AlterProcedureImpl :
{
}
{
    {
        return jjtThis;
    }
}

AlterViewImpl alterView() #AlterViewImpl :
{
}
{
    {
        return jjtThis;
    }
}